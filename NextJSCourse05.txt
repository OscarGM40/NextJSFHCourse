					SECCION 18 NEXT-AUTH

Realmente nuestra custom auth no está mal,pero Next ya provee un sistema de autenticación propio.Usaremos OAuth con Github.
Es tan fácil que podré dejar de referencia esta auth con NextAuth para otros proyectos.Genial

En esta sección, expandiremos nuestro mecanismo de autenticación con Next Auth, puntualmente veremos

1- Proveedores
2- Github como proveedor de autenticación
3- Custom Logins
4- Credenciales como proveedor
5- Sessiones
6- NextAuth JWT
7- Verificación de sesión en el Frontend y Backend

Y Más

			VIDEO 294-295 INSTALAR NEXT AUTH Y CONFIGURARLO

Probablemente lo más raro de NextAuth es que tengo que crear el archivo /pages/api/auth/[...nextauth].js. Esos tres puntos indican que el nombre puede cambiar realmente,es decir,que todas las peticiones van a entrar por ahi.

TIP: puedo configurar incluso que la app mande un email:
EmailProvider({
  server: process.env.MAIL_SERVER,
  from: 'NextAuth.js <no-reply@example.com>'

Todo esto es del lado del servidor,ojo(por eso es en /pages/api/auth).Para el lado del cliente tengo que envolver la app en un Session Provider.De esta forma proporciono la Session a toda la app:

export default function App({
...
  return( <SessionProvider session={session}> ....

despues solo hay que usar el hook useSession cuando necesite acceder a ella.
Fijate que mis usuarios tienen un role y un mongoId.De alguna manera tendremos que hacer un puente entre las autenticaciones por redes sociales	y la custom auth,ya que necesito más de ellas.

Para instalar NextAuth:
>yarn add next-auth <- ya viene con el tipado

IMPORTANTE: fijate que no me deja usar la version 18,hay que cumplir con lo que pida la instalación(la 16.13.2 me valió)

				VIDEO 295 CONFIGURAR NEXTAUTH Y ENLAZAR CON GITHUB 

Recuerda que hay que crear un proyecto en GitHub(ir a settings y despues a developer settings).Relleno todo y me traigo las dos keys:

export default NextAuth({
  providers: [
    GitHubProvider({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
  ],
});

Tras realizar esto fijate que su url es /api/auth/signin.Podria ir alli y logearme,aunque no podemos hacer nada más.

		VIDEO 296 OBTENER INFORMACION DEL USUARIO LOGEADO POR GITHUB

Debemos ser capaces de obtener la información del usuario logeado por el Provider.Desde la documentación voy al _app.ts y creo el Provider.Ahora vamos al contexto AuthProvider y llamamos al Hook:

import { useSession } from 'next-auth/react';

const { data, status } = useSession();

en un efecto intentamos ver que es lo que trae la red social:

  useEffect(() => {
    if(status === 'authenticated'){
      console.log(data.user)
      // dispatch({ type: '[Auth] - Login', payload: data.user as IUser });
    }
  },[status,data])

email: "oscargm28@hotmail.com"
image: "https://avatars.githubusercontent.com/u/64368358?v=4"
name: "Oscar"

Obviamente no hace match con el IUser,le falta el role y el _id.De alguna manera vamos a crear tmb un usuario en la DB,pasandole una DB al Provider.

			VIDEO 297 PROVEEDOR - CREDENCIALES

Vamos a crear dos logins,el segundo para nuestra custom auth.Next ya tiene un provider definido para eso,es el Credentials:

export default NextAuth({
  providers: [
    GitHubProvider({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
    Credentials({ // nuestra custom auth
      name: 'Custom Login',
      credentials: {
        email: {
          label: 'Correo',
          type: 'email',
          placeholder: 'correo@gmail.com',
        },
        password: {
          label: 'Contraseña',
          type: 'password',
          placeholder: 'Password',
        },
      },
      async authorize(credentials) {
        console.log(credentials);
        return null;
      },
    }),

NOTA: NextAuth por defecto trabaja con JWT.Antigüamente se pedia una variable de entorno para la semilla,pero desde hace tiempo se decidió que se llamaría NEXTAUTH_SECRET,asi que tengo que establecerla siempre que use NextAuth para firmar el JWT

				VIDEO 298 CALLBACKS EN NEXT AUTH

Puedo agregar una segunda propiedad callbacks,en la que se puede reconfigurar muchas cosas,por ejemplo,puedo acceder al token o a la sesión y manipular propiedades antes de volver a retornarlas:

 // Callbacks
  callbacks:{ 
    // normalmente son asincronas jwt y session
    async jwt({token,account,user}){
      // esta callback recibe el token y me permite realizar algo,pero despues debo devolverlo de nuevo
      return token;
    },
    // y de forma similar esta cb debe retornar la session,aunque permite manipulaciones antes de hacerlo
    async session({session,token,user}){

      return session
    },
  }
NOTA: una autenticación con un Provider como Github tiene la propiedad account.type == 'oauth'

TIP: si bien no queda muy claro porque se necesita todo lo que se necesita si algun dia necesito hacer lo mismo simplement lo copio

			VIDEO 299 VERIFICAR CORREO Y CONTRASEÑA - LEER DE LA DB

Creamos una funcion que compruebe si el email y la password corresponden a un usuario:

export const checkUserEmailPassword = async (
  email: string,
  password: string
) => {
  await db.connect();
  const user = await UserModel.findOne({ email: email });
  await db.disconnect();

  if (!user) {
    return null;
  }
  if (!bcrypt.compareSync(password, user.password!)) {
    return null;
  }

  const { role, name, _id } = user;
  return {
    _id,
    email: email.toLowerCase(),
    role,
    name,
  };
};

Juntamos los returns en el authorize del [...nextauth]:
     async authorize(credentials) {
        return await dbUsers.checkUserEmailPassword(credentials!.email, credentials!.password);
      },
Fijate que la funcion regresa null o el object con el user.Ya sólo con esto,ya estoy en el punto anterior,pues funciona perfectamente la custom Auth,aunque he tenido que usar sus estilos y url.Pero puedo ver el role,email,_id,...

				VIDEO 300 SIGN OUT

Simplemente llamar a su signOut

			VIDEO 301 CREAR USUARIO BASADO EN OAUTH

Lo primero es crear una función que compruebe si ya hay un usuario con ese email:

export const oAuthToDbUser = async (oAuthEmail: string, oAuthName: string) => {
  await db.connect();
  const user = await UserModel.findOne({ email: oAuthEmail });
  if (user) {
    await db.disconnect();
    const { role, name, email, _id } = user;
    return { _id, email, role, name };
  }
  const newUser = new UserModel({
    email: oAuthEmail,
    name: oAuthName,
    password: '@', // solo queremos un caracter que de fallo
    role: 'client',
  });
  await newUser.save();
  await db.disconnect();

  const { role, name, email, _id } = newUser;
  return { _id, email, role, name };
};
Si ya lo hay,mandamos sus datos,si no lo hay,creamos uno,lo guardamos y devolvemos los campos que se necesiten
Y metemos en el token esta info:
  if (account) {
        token.accessToken = account.accessToken;
        switch (account.type) {
          case 'oauth':
            // verificar si existe y si no crearlo
            token.user = await dbUsers.oAuthToDbUser(
              user?.email || '',
              user?.name || ''
            );
            break;
          case 'credentials':
            token.user = user;
            break;
        }
      }
Perfectamente puedo añadir otros Providers,aunque tendré que generar un proyecto con ellos.Por último,puedo ver que tengo dos pantallas de login.Hay que arreglar esto.

			VIDEO 302 LOGIN PERSONALIZADO CON NEXT AUTH

De igual forma que proveen un signOut también puedo usar su signIn:
import { signIn } from 'next-auth/react';

  const onLoginUser: SubmitHandler<FormModel> = async ({ email, password }) => {
    setShowError(false);

    await signIn('credentials',{email,password})
  };
Fijate que le puedo pasar un Provider como primer argumento.Dado que es nuestro custom login le paso el 'credentials'.Y esta vez si,no queremos poder llegar al login si el usuario esta logeado.Para ello vamos a usar SSR y el método getSession:

export default LoginPage;

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const session = await getSession({ req: ctx.req});

  if (session) {
    return {
      redirect: {
        destination: '/',
        permanent: false,
      },
    };
  }

  return {
    props: {},
  };
};

Fijate que getSession necesitó la req:ctx.req.También recuerda que hay que especificar a Next donde setan mis custom pages de Auth.Esto se hace en la propiedad pages:

  pages:{
    signIn:'/auth/login',
    newUser:'/auth/register'
  }, 
  
			VIDEO 303 	ESPECIFICAR LA DURACION DE LA SESIÓN

El super-saiyan FH tenia un problema con la duración por defecto de la sesión.Tenemos que sobresecribir esta duración con la propiedad session:

  session:{
    maxAge:2592000, // 30 days
    strategy:'jwt',
    updateAge: 86400 // this is for DB operations,

		VIDEO 304 LOGIN PARA LOS PROVIDERS DE OAUTH 

Para poder acceder a los providers también se nos suministra un método:
import { getSession, signIn, getProviders } from 'next-auth/react';

  const [providers, setProviders] = useState<any>({});

  useEffect(() => {
    getProviders().then((prov) => {
      console.log(prov);
      setProviders(prov);
    });
  }, []);
  

Despues solo es iterar filtrando por el custom,que ya lo tenemos:

 {Object.values(providers)
                .filter((p:any) => p.id !== 'credentials')
                .map((provider: any) => {
                return (
                  <Button
                    key={provider.id}
                    variant="outlined"
                    color="primary"
                    sx={{mb:1}}
                    onClick={() => signIn(provider.id)}
                    fullWidth
                  >{provider.name}</Button>
                );
              })}

			VIDEO 305 NEXTJS MIDDLEWARES JUNTO A NEXTAUTH

Tenemos que cambiar la forma en que nuestro middleware trabaja,ya que no vamos a tener el token en la cookie.Obviamente falla y no deja pasar(de echo se queda en bucle)

Ellos recomiendan usar getToken(desde next-auth/jwt) de esta forma:

import { getToken } from 'next-auth/jwt';

export async function middleware(req: NextRequest, ev: NextFetchEvent) {
  const session = await getToken({ req,secret: process.env.NEXTAUTH_SECRET });

  // si no hay session se redirige al login guardando la procedencia
  if(!session){
    const url = req.nextUrl.clone();
    return NextResponse.redirect(`${url.origin}/auth/login?p=${req.page.name}`);
  }

  // si si hay session dejamos pasar por el middleware
  return NextResponse.next() 
}
Perfecto.

		VIDEO 306 ASEGURARNOS QUE TENEMOS UNA DIRECCIÓN

IMPORTANTE: fijate que para usar yup tuve que instalar:
1 STEP
npm install react-hook-form @hookform/resolvers yup

2 STEP
Despues los importo asi:
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';

3 STEP
Defino un objeto Schema:
let schema = yup.object().shape({
  firstName: yup.string().required('the field is required'),
  lastName: yup.string().required('the field is required'),
  address: yup.string().required('the field is required'),
  zip: yup.string().required('the field is required'),
  city: yup.string().required('the field is required'),
  country: yup.string().required('the field is required'),
  phone: yup.string().required('the field is required'),
});

4 STEP
Y se lo paso en la propiedad resolvers al hook useForm:
const { control, register, handleSubmit, formState: { errors }, }
= useForm<FormModel>({
    resolver: yupResolver(schema),
    defaultValues: { ...getAddressFromCookies() },
  });
Desde luego es sencillisimo implementar estas validaciones.


			SECCION 19 MANEJO Y CREACION DE ORDENES

En esta sección manejaremos toda la construcción de la orden, puntualmente veremos:
1- Creación de modelos e interfaces
2- Generación de historial de ordenes
3- Validar montos contra el backend
4- Limpiar carrito de compras
5- Grabación de orden en base de datos

Este es el primer paso para llegar a generar la orden de pago.

			VIDEO 312 MODELO E INTERFAZ PARA UNA ORDEN

Crear esto nos va a dar contexto sobre como lucirá una orden.Fijate que el modelo usa referencias a otras colecciones usando Schema.Types.ObjectId y ref:

const orderSchema = new Schema(
  {
    user: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    orderItems: [
      {
        _id: { type: Schema.Types.ObjectId, ref: 'Product', required: true },
        title: { type: String, required: true },
        size: { type: String, required: true },
        quantity: { type: String, required: true },
        slug: { type: String, required: true },
        image: { type: String, required: true },
        price: { type: String, required: true },
      },
    ],
Si bien tiene un tamaño medio es bastante sencillo

			VIDEO 313 ENDPOINT PARA CREAR UNA ORDEN 

Simulamos la compra de varios articulos y vamos hasta confirmar orden.Es en este botón donde hay que llamar al endpoint.
Verificaremos en el backend los precios de nuevo,realmente vamos a ignorar el front pues puede modificarse.

NOTA: fijate que para comprobar un ObjectId vs un id como string tengo que parsear el ObjectId con new mongoose.Types.ObjectId(p._id).toString().Perfecto:

   const currentPrice = dbProducts.find(
        (p) => new mongoose.Types.ObjectId(p._id).toString() === curr._id
      )?.price;

Bien,en cuanto al servicio del controlador luciría asi:
const createOrder = async (req: NextApiRequest, res: NextApiResponse<Data>) => {
  const { total, orderItems } = req.body as IOrder;

  // 1 verificar que hay un usuario logeado
  const session: any = await getSession({ req });
  if (!session) {
    return res.status(401).json({ message: 'Unauthenticated.Go elsewhere' });
  }

  // 2 crear un arreglo con los ids de los productos a comprar
  const productsIds = orderItems.map((p) => p._id);
  await db.connect();
  const dbProducts = await ProductModel.find({
    _id: { $in: productsIds },
  }).lean();

  // 3 comprobar subTotal con los datos del back y no del front
  try {
    const subTotal = orderItems.reduce((prev, curr) => {
      const currentPrice = dbProducts.find(
        (p) => new mongoose.Types.ObjectId(p._id).toString() === curr._id
      )?.price;
      if (!currentPrice) {
        throw new Error(`Verifique el carrito de nuevo.Producto no existe`);
      }
      return currentPrice * curr.quantity + prev;
    }, 0);

    const taxRate = Number(process.env.NEXT_PUBLIC_TAX_RATE ?? 0);
    const backendTotal = subTotal + subTotal * taxRate;
    if (total !== backendTotal) {
      throw new Error(`El total no cuadra entre front y back`);
    }
    // 4 si llegamos aqui esta todo correcto en la orden
    const userId = session.user._id;
    const newOrder = new OrderModel({
      ...req.body,
      isPaid: false,
      user: userId,
    });
    await newOrder.save();
    return res.status(201).json(newOrder);
  } catch (error: any) {
    await db.disconnect();
    console.log(error);
    res
      .status(400)
      .json({ message: error.message || 'Revise logs en el servidor' });
  }

  return res.status(201).json(req.body);
};

			VIDEO 319 PREVENIR DOBLE POSTEO

Vamos al Provider y hacemos que el onCreate sea un Promise que haga match con dos states del componente(fijate que inteligente fue esto).

Perfectamente puedo crear dos states en cualquier componente:
  const [isPosting, setIsPosting] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

Y despues hacer que cualquier funcion retorne una Promise<hasError:boolean,message:string>(realmente son argumentos,da igual el nombre:
 
  try {
      const { data } = await tesloApi.post<IOrder>('/orders', body);
      dispatch({type:'[Cart] - Order complete'})
      return {
        hasError: false,
        message: data._id!,
      };
    } catch (error) {
      console.log({ error });
      if (axios.isAxiosError(error)) {
        return {
          hasError: true,
          message: (error.response?.data as { message: string }).message,
        };
      }
      return {
        hasError: true,
        message: 'Server Error,please see server logs',
      };
    }
Obviamente,debe ser alguna acción asíncrona si uso Promises,pero fijate que puedo ignorar que sean promises y seguir haciendo match el retorno con dos states,etc.

También creamos una nueva action que limpie el cart
    case '[Cart] - Order complete':
      return {
        ...state,
        cart:[],
        numberOfItems: 0,
        subTotal:0,
        tax:0,
        total:0
      }

				VIDEO 321 OBTENER UNA ORDEN POR ID

Usando SSR en la pagina de orders/:id me paso la orden por props:
export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const { id = '' } = ctx.query as { id: string };
  const session: any = await getSession({ req: ctx.req });

  if (!session) {
    return {
      redirect: {
        destination: `/auth/login?p=/orders/${id}`,
        permanent: false,
      },
    };
  }
  // recuerda hacer el await sobre un método async,aunque él usará await tmb
  const order = await dbOrders.getOrderById(id);
  if (!order) {
    return {
      redirect: {
        destination: `/orders/history`,
        permanent: false,
      },
    };
  }
  // si la orden es de otro no puede verla
  if (order.user !== session.user._id) {
    return {
      redirect: {
        destination: `/orders/history`,
        permanent: false,
      },
    };
  }

  return {
    props: {
      order,
    },
  };
};

				VIDEO 322 MOSTRAR ORDEN EN PANTALLA

Fijate como puedo desestructurar desde un ternario(o desestructuro de uno o de otro).Obviamente ambos objetos, orderValues y el Context tienen las props:

  const { numberOfItems, subTotal, tax, total } = orderValues ? orderValues : useContext(CartContext);

Muy pro desestructurar desde el Context o las props

				VIDEO 324 HISTORIAL DE ORDENES

Creamos un helper que busque las ordenes por id,el cual podemos sacar de la session con getSession({req:ctx.req}):

export const getOrdersByUser = async (userId: string): Promise<IOrder[]> => {
  if (!isValidObjectId(userId)) {
    return [];
  }
  await db.connect();
  const orders = await OrderModel.find({ user: userId }).lean();
  await db.disconnect();

  return JSON.parse(JSON.stringify(orders));
};

Desde aqui ya tenemos todo.En la proxima seccion veremos como pagar con PayPal.

			SECCION 20 PAGOS CON PAYPAL Y TARJETA DE CREDITO

Esta sección está enfocada en realizar los cobros utilizando PayPal y Tarjetas de Crédito utilizando PayPal también. Específicamente:

1- Botones de cobro de Paypal y tarjeta de credito
2- REST Endpoints de cobros
3- Validar pago contra PayPal
4- Información de cómo se pagó una orden
5- Tokens de autenticación
  a- Basic
  b- Bearer
6- Procesos automáticos después del cobro

