					SECCION 18 NEXT-AUTH

Realmente nuestra custom auth no está mal,pero Next ya provee un sistema de autenticación propio.Usaremos OAuth con Github.
Es tan fácil que podré dejar de referencia esta auth con NextAuth para otros proyectos.Genial

En esta sección, expandiremos nuestro mecanismo de autenticación con Next Auth, puntualmente veremos

1- Proveedores
2- Github como proveedor de autenticación
3- Custom Logins
4- Credenciales como proveedor
5- Sessiones
6- NextAuth JWT
7- Verificación de sesión en el Frontend y Backend

Y Más

			VIDEO 294-295 INSTALAR NEXT AUTH Y CONFIGURARLO

Probablemente lo más raro de NextAuth es que tengo que crear el archivo /pages/api/auth/[...nextauth].js. Esos tres puntos indican que el nombre puede cambiar realmente,es decir,que todas las peticiones van a entrar por ahi.

TIP: puedo configurar incluso que la app mande un email:
EmailProvider({
  server: process.env.MAIL_SERVER,
  from: 'NextAuth.js <no-reply@example.com>'

Todo esto es del lado del servidor,ojo(por eso es en /pages/api/auth).Para el lado del cliente tengo que envolver la app en un Session Provider.De esta forma proporciono la Session a toda la app:

export default function App({
...
  return( <SessionProvider session={session}> ....

despues solo hay que usar el hook useSession cuando necesite acceder a ella.
Fijate que mis usuarios tienen un role y un mongoId.De alguna manera tendremos que hacer un puente entre las autenticaciones por redes sociales	y la custom auth,ya que necesito más de ellas.

Para instalar NextAuth:
>yarn add next-auth <- ya viene con el tipado

IMPORTANTE: fijate que no me deja usar la version 18,hay que cumplir con lo que pida la instalación(la 16.13.2 me valió)

				VIDEO 295 CONFIGURAR NEXTAUTH Y ENLAZAR CON GITHUB 

Recuerda que hay que crear un proyecto en GitHub(ir a settings y despues a developer settings).Relleno todo y me traigo las dos keys:

export default NextAuth({
  providers: [
    GitHubProvider({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
  ],
});

Tras realizar esto fijate que su url es /api/auth/signin.Podria ir alli y logearme,aunque no podemos hacer nada más.

		VIDEO 296 OBTENER INFORMACION DEL USUARIO LOGEADO POR GITHUB

Debemos ser capaces de obtener la información del usuario logeado por el Provider.Desde la documentación voy al _app.ts y creo el Provider.Ahora vamos al contexto AuthProvider y llamamos al Hook:

import { useSession } from 'next-auth/react';

const { data, status } = useSession();

en un efecto intentamos ver que es lo que trae la red social:

  useEffect(() => {
    if(status === 'authenticated'){
      console.log(data.user)
      // dispatch({ type: '[Auth] - Login', payload: data.user as IUser });
    }
  },[status,data])

email: "oscargm28@hotmail.com"
image: "https://avatars.githubusercontent.com/u/64368358?v=4"
name: "Oscar"

Obviamente no hace match con el IUser,le falta el role y el _id.De alguna manera vamos a crear tmb un usuario en la DB,pasandole una DB al Provider.

			VIDEO 297 PROVEEDOR - CREDENCIALES

Vamos a crear dos logins,el segundo para nuestra custom auth.Next ya tiene un provider definido para eso,es el Credentials:

export default NextAuth({
  providers: [
    GitHubProvider({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
    Credentials({ // nuestra custom auth
      name: 'Custom Login',
      credentials: {
        email: {
          label: 'Correo',
          type: 'email',
          placeholder: 'correo@gmail.com',
        },
        password: {
          label: 'Contraseña',
          type: 'password',
          placeholder: 'Password',
        },
      },
      async authorize(credentials) {
        console.log(credentials);
        return null;
      },
    }),

NOTA: NextAuth por defecto trabaja con JWT.Antigüamente se pedia una variable de entorno para la semilla,pero desde hace tiempo se decidió que se llamaría NEXTAUTH_SECRET,asi que tengo que establecerla siempre que use NextAuth para firmar el JWT

				VIDEO 298 CALLBACKS EN NEXT AUTH

Puedo agregar una segunda propiedad callbacks,en la que se puede reconfigurar muchas cosas,por ejemplo,puedo acceder al token o a la sesión y manipular propiedades antes de volver a retornarlas:

 // Callbacks
  callbacks:{ 
    // normalmente son asincronas jwt y session
    async jwt({token,account,user}){
      // esta callback recibe el token y me permite realizar algo,pero despues debo devolverlo de nuevo
      return token;
    },
    // y de forma similar esta cb debe retornar la session,aunque permite manipulaciones antes de hacerlo
    async session({session,token,user}){

      return session
    },
  }
NOTA: una autenticación con un Provider como Github tiene la propiedad account.type == 'oauth'

TIP: si bien no queda muy claro porque se necesita todo lo que se necesita si algun dia necesito hacer lo mismo simplement lo copio

			VIDEO 299 VERIFICAR CORREO Y CONTRASEÑA - LEER DE LA DB

Creamos una funcion que compruebe si el email y la password corresponden a un usuario:

export const checkUserEmailPassword = async (
  email: string,
  password: string
) => {
  await db.connect();
  const user = await UserModel.findOne({ email: email });
  await db.disconnect();

  if (!user) {
    return null;
  }
  if (!bcrypt.compareSync(password, user.password!)) {
    return null;
  }

  const { role, name, _id } = user;
  return {
    _id,
    email: email.toLowerCase(),
    role,
    name,
  };
};

Juntamos los returns en el authorize del [...nextauth]:
     async authorize(credentials) {
        return await dbUsers.checkUserEmailPassword(credentials!.email, credentials!.password);
      },
Fijate que la funcion regresa null o el object con el user.Ya sólo con esto,ya estoy en el punto anterior,pues funciona perfectamente la custom Auth,aunque he tenido que usar sus estilos y url.Pero puedo ver el role,email,_id,...

				VIDEO 300 SIGN OUT

Simplemente llamar a su signOut

			VIDEO 301 CREAR USUARIO BASADO EN OAUTH

Lo primero es crear una función que compruebe si ya hay un usuario con ese email:

export const oAuthToDbUser = async (oAuthEmail: string, oAuthName: string) => {
  await db.connect();
  const user = await UserModel.findOne({ email: oAuthEmail });
  if (user) {
    await db.disconnect();
    const { role, name, email, _id } = user;
    return { _id, email, role, name };
  }
  const newUser = new UserModel({
    email: oAuthEmail,
    name: oAuthName,
    password: '@', // solo queremos un caracter que de fallo
    role: 'client',
  });
  await newUser.save();
  await db.disconnect();

  const { role, name, email, _id } = newUser;
  return { _id, email, role, name };
};
Si ya lo hay,mandamos sus datos,si no lo hay,creamos uno,lo guardamos y devolvemos los campos que se necesiten
Y metemos en el token esta info:
  if (account) {
        token.accessToken = account.accessToken;
        switch (account.type) {
          case 'oauth':
            // verificar si existe y si no crearlo
            token.user = await dbUsers.oAuthToDbUser(
              user?.email || '',
              user?.name || ''
            );
            break;
          case 'credentials':
            token.user = user;
            break;
        }
      }
Perfectamente puedo añadir otros Providers,aunque tendré que generar un proyecto con ellos.Por último,puedo ver que tengo dos pantallas de login.Hay que arreglar esto.

			VIDEO 302 LOGIN PERSONALIZADO CON NEXT AUTH

De igual forma que proveen un signOut también puedo usar su signIn:
import { signIn } from 'next-auth/react';

  const onLoginUser: SubmitHandler<FormModel> = async ({ email, password }) => {
    setShowError(false);

    await signIn('credentials',{email,password})
  };
Fijate que le puedo pasar un Provider como primer argumento.Dado que es nuestro custom login le paso el 'credentials'.Y esta vez si,no queremos poder llegar al login si el usuario esta logeado.Para ello vamos a usar SSR y el método getSession:

export default LoginPage;

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const session = await getSession({ req: ctx.req});

  if (session) {
    return {
      redirect: {
        destination: '/',
        permanent: false,
      },
    };
  }

  return {
    props: {},
  };
};

Fijate que getSession necesitó la req:ctx.req.También recuerda que hay que especificar a Next donde setan mis custom pages de Auth.Esto se hace en la propiedad pages:

  pages:{
    signIn:'/auth/login',
    newUser:'/auth/register'
  }, 
  
			VIDEO 303 	ESPECIFICAR LA DURACION DE LA SESIÓN

El super-saiyan FH tenia un problema con la duración por defecto de la sesión.Tenemos que sobresecribir esta duración con la propiedad session:

  session:{
    maxAge:2592000, // 30 days
    strategy:'jwt',
    updateAge: 86400 // this is for DB operations,

		VIDEO 304 LOGIN PARA LOS PROVIDERS DE OAUTH 

Para poder acceder a los providers también se nos suministra un método:
import { getSession, signIn, getProviders } from 'next-auth/react';

  const [providers, setProviders] = useState<any>({});

  useEffect(() => {
    getProviders().then((prov) => {
      console.log(prov);
      setProviders(prov);
    });
  }, []);
  

Despues solo es iterar filtrando por el custom,que ya lo tenemos:

 {Object.values(providers)
                .filter((p:any) => p.id !== 'credentials')
                .map((provider: any) => {
                return (
                  <Button
                    key={provider.id}
                    variant="outlined"
                    color="primary"
                    sx={{mb:1}}
                    onClick={() => signIn(provider.id)}
                    fullWidth
                  >{provider.name}</Button>
                );
              })}

			VIDEO 305 NEXTJS MIDDLEWARES JUNTO A NEXTAUTH

Tenemos que cambiar la forma en que nuestro middleware trabaja,ya que no vamos a tener el token en la cookie.Obviamente falla y no deja pasar(de echo se queda en bucle)

Ellos recomiendan usar getToken(desde next-auth/jwt) de esta forma:

import { getToken } from 'next-auth/jwt';

export async function middleware(req: NextRequest, ev: NextFetchEvent) {
  const session = await getToken({ req,secret: process.env.NEXTAUTH_SECRET });

  // si no hay session se redirige al login guardando la procedencia
  if(!session){
    const url = req.nextUrl.clone();
    return NextResponse.redirect(`${url.origin}/auth/login?p=${req.page.name}`);
  }

  // si si hay session dejamos pasar por el middleware
  return NextResponse.next() 
}
Perfecto.

		VIDEO 306 ASEGURARNOS QUE TENEMOS UNA DIRECCIÓN

IMPORTANTE: fijate que para usar yup tuve que instalar:
1 STEP
npm install react-hook-form @hookform/resolvers yup

2 STEP
Despues los importo asi:
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';

3 STEP
Defino un objeto Schema:
let schema = yup.object().shape({
  firstName: yup.string().required('the field is required'),
  lastName: yup.string().required('the field is required'),
  address: yup.string().required('the field is required'),
  zip: yup.string().required('the field is required'),
  city: yup.string().required('the field is required'),
  country: yup.string().required('the field is required'),
  phone: yup.string().required('the field is required'),
});

4 STEP
Y se lo paso en la propiedad resolvers al hook useForm:
const { control, register, handleSubmit, formState: { errors }, }
= useForm<FormModel>({
    resolver: yupResolver(schema),
    defaultValues: { ...getAddressFromCookies() },
  });
Desde luego es sencillisimo implementar estas validaciones.


			SECCION 19 MANEJO Y CREACION DE ORDENES

En esta sección manejaremos toda la construcción de la orden, puntualmente veremos:
1- Creación de modelos e interfaces
2- Generación de historial de ordenes
3- Validar montos contra el backend
4- Limpiar carrito de compras
5- Grabación de orden en base de datos

Este es el primer paso para llegar a generar la orden de pago.

			VIDEO 312 MODELO E INTERFAZ PARA UNA ORDEN

Crear esto nos va a dar contexto sobre como lucirá una orden.Fijate que el modelo usa referencias a otras colecciones usando Schema.Types.ObjectId y ref:

const orderSchema = new Schema(
  {
    user: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    orderItems: [
      {
        _id: { type: Schema.Types.ObjectId, ref: 'Product', required: true },
        title: { type: String, required: true },
        size: { type: String, required: true },
        quantity: { type: String, required: true },
        slug: { type: String, required: true },
        image: { type: String, required: true },
        price: { type: String, required: true },
      },
    ],
Si bien tiene un tamaño medio es bastante sencillo

			VIDEO 313 ENDPOINT PARA CREAR UNA ORDEN 

Simulamos la compra de varios articulos y vamos hasta confirmar orden.Es en este botón donde hay que llamar al endpoint.
Verificaremos en el backend los precios de nuevo,realmente vamos a ignorar el front pues puede modificarse.

NOTA: fijate que para comprobar un ObjectId vs un id como string tengo que parsear el ObjectId con new mongoose.Types.ObjectId(p._id).toString().Perfecto:

   const currentPrice = dbProducts.find(
        (p) => new mongoose.Types.ObjectId(p._id).toString() === curr._id
      )?.price;

Bien,en cuanto al servicio del controlador luciría asi:
const createOrder = async (req: NextApiRequest, res: NextApiResponse<Data>) => {
  const { total, orderItems } = req.body as IOrder;

  // 1 verificar que hay un usuario logeado
  const session: any = await getSession({ req });
  if (!session) {
    return res.status(401).json({ message: 'Unauthenticated.Go elsewhere' });
  }

  // 2 crear un arreglo con los ids de los productos a comprar
  const productsIds = orderItems.map((p) => p._id);
  await db.connect();
  const dbProducts = await ProductModel.find({
    _id: { $in: productsIds },
  }).lean();

  // 3 comprobar subTotal con los datos del back y no del front
  try {
    const subTotal = orderItems.reduce((prev, curr) => {
      const currentPrice = dbProducts.find(
        (p) => new mongoose.Types.ObjectId(p._id).toString() === curr._id
      )?.price;
      if (!currentPrice) {
        throw new Error(`Verifique el carrito de nuevo.Producto no existe`);
      }
      return currentPrice * curr.quantity + prev;
    }, 0);

    const taxRate = Number(process.env.NEXT_PUBLIC_TAX_RATE ?? 0);
    const backendTotal = subTotal + subTotal * taxRate;
    if (total !== backendTotal) {
      throw new Error(`El total no cuadra entre front y back`);
    }
    // 4 si llegamos aqui esta todo correcto en la orden
    const userId = session.user._id;
    const newOrder = new OrderModel({
      ...req.body,
      isPaid: false,
      user: userId,
    });
    await newOrder.save();
    return res.status(201).json(newOrder);
  } catch (error: any) {
    await db.disconnect();
    console.log(error);
    res
      .status(400)
      .json({ message: error.message || 'Revise logs en el servidor' });
  }

  return res.status(201).json(req.body);
};

			VIDEO 319 PREVENIR DOBLE POSTEO

Vamos al Provider y hacemos que el onCreate sea un Promise que haga match con dos states del componente(fijate que inteligente fue esto).

Perfectamente puedo crear dos states en cualquier componente:
  const [isPosting, setIsPosting] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

Y despues hacer que cualquier funcion retorne una Promise<hasError:boolean,message:string>(realmente son argumentos,da igual el nombre:
 
  try {
      const { data } = await tesloApi.post<IOrder>('/orders', body);
      dispatch({type:'[Cart] - Order complete'})
      return {
        hasError: false,
        message: data._id!,
      };
    } catch (error) {
      console.log({ error });
      if (axios.isAxiosError(error)) {
        return {
          hasError: true,
          message: (error.response?.data as { message: string }).message,
        };
      }
      return {
        hasError: true,
        message: 'Server Error,please see server logs',
      };
    }
Obviamente,debe ser alguna acción asíncrona si uso Promises,pero fijate que puedo ignorar que sean promises y seguir haciendo match el retorno con dos states,etc.

También creamos una nueva action que limpie el cart
    case '[Cart] - Order complete':
      return {
        ...state,
        cart:[],
        numberOfItems: 0,
        subTotal:0,
        tax:0,
        total:0
      }

				VIDEO 321 OBTENER UNA ORDEN POR ID

Usando SSR en la pagina de orders/:id me paso la orden por props:
export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const { id = '' } = ctx.query as { id: string };
  const session: any = await getSession({ req: ctx.req });

  if (!session) {
    return {
      redirect: {
        destination: `/auth/login?p=/orders/${id}`,
        permanent: false,
      },
    };
  }
  // recuerda hacer el await sobre un método async,aunque él usará await tmb
  const order = await dbOrders.getOrderById(id);
  if (!order) {
    return {
      redirect: {
        destination: `/orders/history`,
        permanent: false,
      },
    };
  }
  // si la orden es de otro no puede verla
  if (order.user !== session.user._id) {
    return {
      redirect: {
        destination: `/orders/history`,
        permanent: false,
      },
    };
  }

  return {
    props: {
      order,
    },
  };
};

				VIDEO 322 MOSTRAR ORDEN EN PANTALLA

Fijate como puedo desestructurar desde un ternario(o desestructuro de uno o de otro).Obviamente ambos objetos, orderValues y el Context tienen las props:

  const { numberOfItems, subTotal, tax, total } = orderValues ? orderValues : useContext(CartContext);

Muy pro desestructurar desde el Context o las props

				VIDEO 324 HISTORIAL DE ORDENES

Creamos un helper que busque las ordenes por id,el cual podemos sacar de la session con getSession({req:ctx.req}):

export const getOrdersByUser = async (userId: string): Promise<IOrder[]> => {
  if (!isValidObjectId(userId)) {
    return [];
  }
  await db.connect();
  const orders = await OrderModel.find({ user: userId }).lean();
  await db.disconnect();

  return JSON.parse(JSON.stringify(orders));
};

Desde aqui ya tenemos todo.En la proxima seccion veremos como pagar con PayPal.

			SECCION 20 PAGOS CON PAYPAL Y TARJETA DE CREDITO

Esta sección está enfocada en realizar los cobros utilizando PayPal y Tarjetas de Crédito utilizando PayPal también. Específicamente:

1- Botones de cobro de Paypal y tarjeta de credito
2- REST Endpoints de cobros
3- Validar pago contra PayPal
4- Información de cómo se pagó una orden
5- Tokens de autenticación
  a- Basic
  b- Bearer
6- Procesos automáticos después del cobro

Fijate que es una buena opción para tener bien claro el flujo de pagos con PayPal,al menos volver a memorizarlo.

			VIDEO 331 MODIFICACIONES ADICIONALES EN LA ORDEN

Modificamos tanto el Schema como la interfaz para una Order agregando transactionId:

export interface IOrder {
  _id?: string;
  user?: IUser | string; // puede que sea el id o todo el User
  orderItems: IOrderItem[];
  shippingAddress: ShippingAddress;
  paymentResult?: string;
  numberOfItems: number;
  subTotal: number;
  tax: number;
  total: number;
  isPaid: boolean;
  paidAt?: string;
  transactionId?: string;
}
También hacemos un toFixed(2) al total,porque PayPal dará error con muchos decimales.

		VIDEO 332 PAYPAL DELEVOPER DASHBOARD- CUENTAS Y FAKE PAYPAL INTRO

La URL de testing para PayPal es:
https://developer.paypal.com/home/
Accedo alli y me registro.Recuerda siempre estar en el modo Sandbox.Creamos una app y eligo tipo Merchant(vendedor).
Eligo el correo janegarrapata@business.example.com y doy en crear.

Se me proporcionaran los tokens publicos y privados,los guardamos

NOTA: podemos ir a Sandbox/accounts y crear cuentas de comprador(personal) o vendedor(business)

Recuerda cambiar la cuenta del comprador fake con una password más sencilla.

			VIDEO 333 INTEGRAR BOTONES DE PAYPAL

En este punto se recomienda usar una libreria para integrar los botones de paypal.Además que tiene soporte para TS hace sencillisimo usar sus botones:
npm i @paypal/react-paypal-js

Para usarlo hay que usar un Provider:
import { PayPalScriptProvider, PayPalButtons } from "@paypal/react-paypal-js";

Ese provider hay que pasarle unas opciones,como el token del cliente,la currency,etc.

const initialOptions = {
    "client-id": "test",
    currency: "USD",
    intent: "capture",
    "data-client-token": "abc123xyz==",
};

export default function App() {
    return (
        <PayPalScriptProvider options={initialOptions}>
            <PayPalButtons />
        </PayPalScriptProvider>
    );
}

Fijate que incluso nos dan un useReducer con varios states:

const [{ isPending }] = usePayPalScriptReducer();

return (
    <>
        {isPending ? <div className="spinner" /> : null}
        <PayPalButtons />
    </>

NOTA: al pagar con paypal se genera un id del pago.Ese ID lo validaremos con el backend.

			VIDEO 334 VERIFICAR PAGO DESDE EL BACKEND

Creo un nuevo archivo en pages/api/orders/pay.ts.Gestionaremos el POST:

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  switch (req.method) {
    case 'POST':
      return payOrder(req, res);
    default:
      return res.status(400).json({ message: 'Bad request' });
  }
}

const payOrder = (req: NextApiRequest, res: NextApiResponse<Data>) => {
  return res.status(200).json({ message: 'Orden pagada' });
};

IMPORTANTISIMO: Fernando provee dos urls para generar tokens(con unos minutos de validez) y para comprobar orders(las que emiten ellos).Los debo pegar en el .env:

PAYPAL_OAUTH_URL=https://api-m.sandbox.paypal.com/v1/oauth2/token
PAYPAL_ORDERS_URL=https://api.sandbox.paypal.com/v2/checkout/orders

Fijate que el segundo seria checkout/orders/:id,nos falta concatenar el id de la orden que se genera al pagar.
NOTA:el token que genera paypal es un Bearer token

			VIDEO 335 PAYPAL OAUTH TOKEN -GENERAR TOKEN DE LA ORDEN

Vamos a generar un token de acceso.Puedo probar en POSTMAN mandando una peticion POST con una basic auth(username es el client Id y password el secret key)
Aun faltará mandar en un x-www-urlformencoded el grant_type con el valor de client_credentials

Veré que la respuesta es un objeto con varias propiedades,una de ellas es el access_token
NOTA: en Postman puedo ir a Code y ver lo que hay que construir en Node,Curl,Java,Python,etc...

Sabiendo todo esto vamos a hacer un endpoint que devuelva esto.Fijate en el uso de Buffer.from(string,charset),de new URLSearchParams por querer usar un x-www-urlformencoded y de los headers.Muy interesante:

const getPaypalBearerToken = async (): Promise<string | null> => {
  const PAYPAL_CLIENT = process.env.NEXT_PUBLIC_PAYPAL_CLIENT_ID;
  const PAYPAL_SECRET = process.env.PAYPAL_SECRET;

  // para crear la basic Auth hay que usar Buffer.from().Fijate en el separador(los dos puntos).Lleva un codificador en utf-8
  const base64Token = Buffer.from(`${PAYPAL_CLIENT}:${PAYPAL_SECRET}`,'utf-8').toString('base64');

  // dado que el body tiene que estar en x-www-form-urlencode tengo que construir el body con la clase URLSearchParams(string).Esto manda el string del param en base64
  const body = new URLSearchParams('grant_type=client_credentials');

  try {
    const { data } = await axios.post(
      process.env.PAYPAL_OAUTH_URL ?? '',
      body,
      {
        headers: {
          Authorization: `Basic ${base64Token}`,
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      }
    );
    return data.access_token;
  } catch (error) {
    if (axios.isAxiosError(error)) {
      console.log(error.response?.data);
    } else {
      console.log(error);
    }
    return null;
  }
};

Ya solo falta que el endpoint nuestro llame a este método y devuelva el access_token:


const payOrder = async (req: NextApiRequest, res: NextApiResponse<Data>) => {
  const paypalBearerToken = await getPaypalBearerToken();

  if (!paypalBearerToken) {
    return res
      .status(400)
      .json({ message: 'No se pudo confirmar el token de paypala' });
  }
  return res.status(200).json({ message: paypalBearerToken });
};

Recuerda que este paso es fundamental,ya que mi API debe de confirmar con PayPal que efectivamente se ha pagado y no confiar más que en su API.Para ello debo generar el token de la orden y constrastarla.

			VIDEO 336 CONFIRMAR ORDEN PAGADA MEDIANTE PAYPAL

Para confirmar si la orden esta pagada también tenemos la url,solo que tenemos la Url sin el id en las variables de entorno(el id lo genera PayPal y viene en la respuesta,además le hemos creado el campo transactionId tmb)

Asi pues mando el bearer token a por ejemplo, https://api.sandbox.paypal.com/v2/checkout/orders/1WL43029JX011835R  Veré mucha info,como la dirección,el estado del pago,la cantidad,email_address del comprador y vendedor,etc:

 "id": "1WL43029JX011835R",
    "intent": "CAPTURE",
    "status": "COMPLETED",
    "payment_source": {
        "paypal": {
            "email_address": "johngarrapata@personal.example.com",
            "account_id": "CBJLP7VVNAGES",
            "name": {
                "given_name": "John",
                "surname": "Doe"
            },
            "address": {
                "country_code": "ES"
            }
        }
    },
    "purchase_units": [
        {
            "reference_id": "default",
            "amount": {
                "currency_code": "USD",
                "value": "86.25"
            },
            "payee": {
                "email_address": "janegarrapata@business.example.com",
                "merchant_id": "ECMQA9WZEC8ES"
            },
            "shipping": {
                "name": {
                    "full_name": "John Doe"
                },
                "address": {
                    "address_line_1": "calle Vilamar� 76993- 17469",
                    "admin_area_2": "Albacete",
                    "admin_area_1": "Albacete",
                    "postal_code": "02001",
                    "country_code": "ES"
                }
            },
            "payments": {
                "captures": [
                    {
NOTA: para poder ver lo que devuelve este endpoint tengo que mandar el token anterior como un Bearer Token(esta es un GET)

DAdo que necesitamos ese transactionId lo vamos a mandar por el body del GET como un x-www-form-urlencoded:


  const { transactionId = '', orderId = '' } = req.body;
  // console.log({ transactionId, orderId });

  const { data } = await axios.get<IPaypal.PaypalOrderStatusResponse>(
    `${process.env.PAYPAL_ORDERS_URL}/${transactionId}`,
    {
      headers: { Authorization: 'Bearer ' + paypalBearerToken },
    }
  );

  if (data.status !== 'COMPLETED') {
    return res.status(401).json({ message: 'Orden no reconocida' });
  }

  await db.connect();
  const dbOrder = await OrderModel.findById(orderId);
  // console.log({dbOrder})
  if (!dbOrder) {
    await db.disconnect();
    return res.status(400).json({ message: 'Orden no existe en nuestra DB' });
  }

  if (dbOrder.total !== Number(data.purchase_units[0].amount.value)) {
    await db.disconnect();
    return res
      .status(400)
      .json({ message: 'Los montos de Paypal y nuestra orden no coinciden' });
  }
  dbOrder.transactionId = transactionId;
  dbOrder.isPaid = true;
  dbOrder.save();

  await db.disconnect();

  return res.status(200).json({ message: 'Orden pagada' });
};

Fijate que de momento tengo que instertar manualmente el transactionId y la orderId,pero funciona correctamente esta lógica

				VIDEO 337 ACTUALIZAR PANTALLA DE PAGOS

Al realizar un pago correcto debemos cambiar la UI.Fijate que ya tenemos el endpoint,realmente es solo llamarlo,que estabamos haciendo un console.log:

  const [isPaying, setIsPaying] = useState(false);

  const onOrderCompleted = async (details: OrderResponseBody) => {
    if (details.status !== 'COMPLETED') {
      return alert('No hay pago en Paypal');
    }
    setIsPaying(true);
    try {
      await tesloApi.post(`/orders/pay`, {
        transactionId: details.id,
        orderId: order._id,
      });
      router.reload();
    } catch (error) {
      setIsPaying(false);
      console.log(error);
      alert('Error');
    }
  };

Single Responsability Principle: cada clase debe tener una única responsabilidad.Es el principio más fácil de entender,y es la S en SOLID.
