				SECCION 05 POKEMON STATIC - CONTINUACIÓN APP POKEMONS

En esta sección nos vamos a preocupar en hidratar la aplicación.React es capaz de modificar ese contenido estático perfectamente.Fijate que esta feature es increiblemente poderosa.
Recuerda,el hecho de que el contenido sea generado de manera estática no significa que no puedo modificarlo despues(incluso usaré useReducer).

En esta sección trabajaremos con la hidratación de nuestro contenido estático con código de React. También aprenderemos a utilizar librerías de terceros aunque estas no fueran escritas en TypeScript.

Adicionalmente hay varias tareas que nos ayudarán a reforzar todo lo aprendido hasta el momento.

					VIDEO 62 GUARDAR EN LOCALSTORAGE

Si intento acceder al localStorage de esta forma voy a ver este error:

const PokemonPage: NextPage<Props> = ({ pokemon }) => {

  const onToggleFavorite = () => {
    localStorage.setItem('favorites',`${pokemon.id}`);
  }
  localStorage.getItem('favorites') <- aqui voy a ver que es el backend el que intenta acceder al localStorage y obviamente sólo existe en el frontend.

Server Error
ReferenceError: localStorage is not defined 

Si bien hay librerias para poder acceder al localStorage desde el backend 
Este error sucede porque en esa instrucción estoy en node y no sobre el objeto window:
console.log(typeof window); <- si hago esto veré que da undefined en la consola del servidor pero que devuelve un objeto en la consola del browser.
Con todo esto en mente vamos a resolver la tarea pues

			VIDEO 63 GUARDAR EN EL LOCALSTORAGE EL ARREGLO DE FAVORITOS

Dado que hay que usar un arreglo y es una función auxiliar lo mejores crearla como una utilidad:

const toggleFavorite = (id: number) => {

  const favorites: number[] = JSON.parse(localStorage.getItem('favorites') || '[]');
  
  const isFavorited = favorites.includes(id);

  if (isFavorited) {
    const newFavorites = favorites.filter(pokeId => pokeId !== id);
    localStorage.setItem('favorites', JSON.stringify(newFavorites));
  } else {
    localStorage.setItem('favorites', JSON.stringify([...favorites, id]));
  }
}

export default {
  toggleFavorite
}

				VIDEO 64 LEER Y VERIFICAR SI EXISTE EN FAVORITOS

Ahora queremos cambiar el texto del boton de Favoritos(guardar/sacar de favoritos)
Fijate que se nos presenta el mismo problema al estar en Next,ya que el componente tiene ámbito tanto en el servidor como en el browser(es porqué es una página?? o esto es para todo componente de React en Next??).
Una simple validación filtrará esto:

const existsInFavorites = (id: number): boolean => {
  if(typeof window === 'undefined') return false;
  const favorites: number[] = JSON.parse(localStorage.getItem('favorites') || '[]');
  return favorites.includes(id);
}
Fijate que tendré que usar mucho typeof window al usar frameworks híbridos.

						VIDEO 65 PANTALLA DE FAVORITOS

Primeramente vamos a cargar en un efecto el array de ids:

const Favorites: NextPage<Props> = () => {
  const [favoritePokemons, setFavoritePokemons] = useState<number[]>([]);

  useEffect(() =>{
    setFavoritePokemons(localFavorites.pokemons);
  },[])

TIP: fijate que puedo ir a las devTools y buscar por el nombre del componente,ya que es una locura buscar en el árbol.Fijate que puedo ver su useState con su carga(en este caso veré el arreglo de ids) y el useEffect,...Muy interesante.

			VIDEO 66 CONSTRUIR EL LISTADO DE POKEMONS FAVORITOS

Simplemente seguir las instrucciones.Fijate que cuando se haga el build no veré el efecto de esta navegación:
 const router = useRouter();

  const onFavoriteClicked = () => {
    router.push(`/pokemon/${pokemonId}`);
  };

  return (
    <Grid xs={6} sm={3} md={2} xl={1} key={pokemonId}>
      <Card
        hoverable
        clickable
        css={{ padding: "10px" }}
        onClick={onFavoriteClicked}
      >
Ya que en el npm run dev estoy en el backend,pero esto será servido con SSG.Comprobarlo.

				VIDEO 68 LIBRERIA EXTERNA CANVAS-CONFETTI

NOTA: puedo hacer un hard refresh con CTRL+SHIFT+r.
Esta libreria CanvasConfetti puede ser un tanto llamativa pero la vamos a usar:
>npm i canvas-confetti 
> npm i @types/canvas-confetti -D
Para usarla simplemente hay que configurar el método confetti:

  if(!isInFavorites){
    confetti({
    zIndex:999,
    particleCount:100,
    spread: 160,
    angle: -100,
    origin:{
      x:0.9,
      y:0.1
    }
    })
  }

				TAREA 69 POKEMON BY NOMBRE

Seguir las instrucciones.Recuerda que debo especificar todos los paths posibles.
IMPORTANTE: realmente la API nos devuelve demasiada data.Sería mejor solo coger la necesaria antes de cachearla.

				VIDEO 72 CENTRALIZAR LA DATA 

Dado que las dos peticiones son similares puedo resumir un poco todo:

export const getPokemonInfo = async (nameOrId: string) => {
  const { data } = await pokeApi.get<PokemonResponse>(`pokemon/${nameOrId}`)

  return {
    name: data.name,
    id: data.id,
    sprites: data.sprites
  }
Ahora las dos llamadas a getStaticProps serán mucho más simple:
export const getStaticProps: GetStaticProps = async (ctx) => {
  const { name } = ctx.params as { name: string };

  return {
    props: {
      pokemon: await getPokemonInfo(name),
    },
  };
};

TIP: por último vamos a usar url friendly.En vez de usar pokemon/5 es mejor usar una url tipo name/bulbasaur.A los bots de Google les interesa que la url sea amigable y penalizarán que no lo sea.
 onClick={() => router.push(`/name/${pokemon.name}`)}

				VIDEO 73 OPEN GRAPH META TAGS		

Parte de ser SEO friendly es que se pueda compartir en redes los productos que se están vendiendo,etc.
Con Open Graph Meta Tags se puede conseguir esto.Estas tags irán en el <head>  siempre comienzan con og antes de la property(de open graph?):

<meta property="og:title" content="How to Become an SEO Expert (8 Steps)" />
<meta property="og:description" content="Get from SEO newbie to SEO pro in 8 simple steps." />
<meta property="og:image" content="https://ahrefs.com/blog/wp-content/uploads/2019/12/fb-how-to-become-an-seo-expert.png" />

Parece que sólo valen para Facebook,para pasarle una imagen,title,description para cuando se vea mi contenido en Facebook.
TIP: para ver la url actual lo tengo en window.location.origin:

const origin = (typeof window !== "undefined" && window.location.origin) || "";
<meta property="og:title" content={`Información sobre ${title}`} />
<meta property="og:description" content={`Esta es la página sobre ${title}`} />
<meta property="og:image" content={`${origin}/img/banner.png`} />

				VIDEO 74 DESPLIEGUE EN VERCEL

Lo mejor es desplegarlo mediante un repo remoto en Github | Gitlab o BitBucket.
OJO: hay que especificar la rama remota a desplegar,ya que Vercel espera que sea main.O hago una PR contra main,o especifico la rama.
Tras el deploy podría pegar una url de un pokemon en Facebook(al tratar de crear un post) y debería ver como funcionan los meta tags og.
NOTA: cada red social tiene unos meta tags que reconoce,los de Twitter o Instagram serán diferentes,en este ejemplo sólo hemos usado el estandar.

TIP: Vercel se quedará en modo watch con esa rama.Cualquier commit sucesivo hará el pre-deploy de la app.

		SECCION 06 ISR - INCREMENTAL STATIC REGENERATION & ISG - INCREMENTAL STATIC GENERATION 

Esta sección es muy pequeña,pero el ISR es algo que debo conocer.Mediante Incremental Static Regeneration puedo volver a generar(regeneration) todo lo que tenia en estático(mediante Static Site Generation)cada determinado tiempo(24h,5h 7d,...)

La primera conexión de un usuario que pida los datos tras ese tiempo será la única que consulte a la API,las demás se servirán desde el file system donde está la app,ya que en esa primera ocasión se recreará la caché.
En resumen,mediante ISG creo un cache cada X tiempo(a diferencia de SSG que creó una única cache).

Esta es una sección pequeña pero nos ayudará a comprender sobre dos formas de expandir nuestra generación estática con una configuración muy simple.

El objetivo es que nuestro servidor de Next pueda almacenar respuestas para su futuro uso y a la vez que pueda revalidar el contenido previamente generado.

Hay que tener en cuenta que si eligo 24h no podré cambiar nada durante cada intervalo de 24h,podría ser mucho tiempo o demasiado poco,...

		VIDEO 80-81 CONTINUACIÓN ISG - INCREMENTAL STATIC REGENERATION

Parece que voy a ver también las diferencias entre Static Site Generation y Static Site Regeneration.
Recuerda que al llamar a getStaticProps en una NextPage hago que sea estatica y cacheada en build time.
TIP: realmente ya sabia las diferencias entre SSG y SSR(StaticSiteRegeneration).El primero lo hace una vez,el segundo lo puede repetir en base a un calendario.
Bien,vamos a simular a Udemy,que usa ISR cada 24 horas o asi.

IMPORTANTE: para usar ISR simplemente hay que usar la propiedad revalidate en el getStaticProps:
  return {
    props: {
      posts,
    },
    // Next.js will attempt to re-generate the page:
    // - When a request comes in
    // - At most once every 10 seconds
    revalidate: 10, // In seconds
  }

Asi pues elegimos 24h de momento(fijate que es mejor pasarle el cálculo ya hecho para mayor eficiencia:
  return {
    props: {
      pokemon: await getPokemonInfo(id),
    },
    revalidate: 86400,//(60seg*60min*24horas)
  };

					VIDEO 82 PARTE DOS ISG 

NOTA: recuerda que yo tengo cacheado 151 pokemons,pero en la API hay más de mil.Seria genial que de alguna forma pudiera agregarle a esa cache los restantes sin tener que hacer el build.
Es decir,queremos pedir el pokemon 152 y si existiera añadir la página(pero encima en runtime)<- fakin NextJS
IMPORTANTE: recuerda que para ver la página de error habia puesto en el getStaticPaths la propieda fallback a true.Este true no dejará pasar al ISR si existiera la page 152,asi que para usar ISR hay que cambiar fallback a 'blocking'

NOTA: si bien esto funciona ya al buscar un pokemon nuevo que si existe,hay que comprobar y desarrollar la lógica para cuando no exista.Para ello basta con meter en un try catch las peticiones(mediante el helper) a la API:

export const getPokemonInfo = async (nameOrId: string) => {
  try {
    const { data } = await pokeApi.get<PokemonResponse>(`pokemon/${nameOrId}`)

    return {
      name: data.name,
      id: data.id,
      sprites: data.sprites
    }

  } catch (error) {
    return null;
  }
* Un simple null me valdrá.Fijate que permanent en false lo hizo Fernando porque podría ser que esa ruta que ahora no existe existiera en el futuro y la querríamos en el historial si sucediera eso:
  
if(!pokemon) {
    return {
      redirect:{
        destination: '/',
        permanent: false //tiene más sentido del que parece
      }
    }
  }

Y ya está,(recuerda que yarn start levanta la app de producción).Bien,si hago el yarn build veré de nuevo que tengo 151html+json.Pero si levanto la app con yarn start(en  producción) cada petición a un nuevo pokemon que existe y no está cacheado Next lo añade a la cache,al filesystem(lo puedo ver perfectamente).
Esto es la ISR en todo su esplendor,increible.
El siguiente video es una tarea,hacer lo mismo para el name.

			SECCION 07 OPENJIRA EJERCICIO CON MATERIAL UI

Vamos a empezar una nueva aplicación la cual simulará el dashboard de Jira.Crearemos la funcionalidad de crear tareas,borrarlas,editarlas,etc...
Sin embargo lo importante es que lo haré con la función getServerSideProps,la cual Next va a ejecutar bajo demanda.Esto es muy poderoso,ya que pre-fetchea la data,mejorando la UserExperience.
Usaremos la API interna de Next,en vez de una externa.
Estilizaremos con Material UI

Esta sección principalmente se enfoca en la creación del estado global de la interfaz de usuario y la creación de snippets que nos permitan crear todo el cascarón rápidamente.

Puntualmente veremos:
1- Manejo del contexto
2- Material UI
3- Temas de Material UI
4- Creación de snippets
Entre otras cosas importantes.
	
			VIDEO 88-89 INICIO PROYECTO - INSTALACIÓN MATERIAL UI 

Iniciamos un nuevo proyecto con yarn create next-app --typescript.
NOTA: MUI usa emotion como styling engine por defecto.Si quisiera podría usar styled-components(requerirá de otras dependencias a instalar).En este proyecto seguiremos con emotion como motor de estilos:
npm install @mui/material @emotion/react @emotion/styled <- recuerda usar yarn add si voy con yarn.

También pide la fuente y los iconos,ambos puedo usar la CDN.En el caso de los iconos tiene sus pros y contras,ya que la CDN trae todo.Si los instalo asi:
yarn add @mui/icons-material 
favoreceré el tree shaking ya que sólo los iconos que use formarán parte del bundle final de la app(a saber si es cierto).

IMPORTANTE: fijate que vamos a crear el file _document.tsx y con un snippet rellenarlo.Asi tendremos más control sobre el document.
De paso le agrego la CDN para la fuente en el Head de Next de ese file.

IMPORTANTE: desde ya vamos a aprovecharnos de esta libreria y settear un custom theme con la paleta del mode dark.Fijate que requiere de un CssReset:

const basicTheme = createTheme({
  palette: {
    mode: 'dark',
  }
})

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <ThemeProvider theme={basicTheme}>
      <CssBaseline /> <- debo resetear los estilos para usar createTheme
      <Component {...pageProps} />
    </ThemeProvider>
  );

Perfecto,no puede ser más sencillo cambiar el tema.

			VIDEO 90 CREANDO TEMAS EN MATERIAL UI

Realmente debo siempre pensar en reusabilidad y mantenibilidad.La forma anterior de meter un tema en duro en un archivo no es la correcta.Asi que creo el folder themes y el index.ts para trabajar con el patrón barrel:

Creo dos files con el mode light y dark y los exporto a través del barrel file
export const lightTheme = createTheme({
  palette: {
    mode: 'light',
    background:{
      default: grey[300],
    }
  }
})

Fijate como puedo crear los temas que quiera y cambiarlos en runtime,etc.
De echo vamos a settear algunos colores al gusto:
    primary: {
      main: '#4a148c',
    },
    secondary: {
      main: '#19857b',
    },
    error: {
      main: red.A400, <- 400 es el grado de intensidad
    }
  }
					VIDEO 91 CREAR LAYOUT Y NAVBAR

Si bien sólo vamos a tener un layout voy a crear el folder layouts por si tuviera más despues.
Creo el archivo components/layouts/Layout.tsx y devuelvo un Box.

TIP: la prop sx es como el atributo style en html o css en otras librerias.Me permite añadir un estilo en linea,pero además tiene acceso al theme de MUI actual.
Me permite pasar cualquier css(en casi cualquier componente).TIP: puede que venga de extended style(o no).

Fijate como puedo pasar un objeto con cualquier prop o sobrescribir un estilo de cualquier componente de la libreria:
export const darkTheme = createTheme({
  palette: {
    mode: 'dark',
    secondary: {
      main: '#19857b',
    },
    error: {
      main: red.A400,
    },
  },
  components:{
    MuiAppBar:{
      defaultProps:{},
      styleOverrides:{
        root: {
          backgroundColor: '#4a148c',
        }
      }
    }
  }
})
TIP: un Button será un MuiButton,una AppBar será una MuiAppBar,...
NOTA: fijate que por ejemplo podría pasar la elevation en 0 o en 2 a todo el tema.Fijate que es una prop,no es css luego va en defaultProps:
  components:{
    MuiAppBar:{
      defaultProps:{
        elevation: 0,
      },

						VIDEO 93 CREANDO EL SIDEBAR

En MUI el típico Sidebar se conoce como Drawer.Puedo ver en la doc de la libreria que hay muchos,y muy útiles,como el típico que se recoge a iconos para dashboards.
 <Drawer anchor="left" open={true} onClose={() => console.log("cerrando")}>
      {/* un box es como un div,nada más */}
      <Box sx={{ width: "250px", }} >
        
        <Box sx={{ padding: "5px 10px" }}>
          <Typography variant="h4">Menú</Typography>
        </Box>

        <List>
          {menuItems.map((text, index) => (
            <ListItem button key={text}>
              <ListItemIcon>
                {index % 2 === 0 ? <InboxOutlined /> : <MailOutlined />}
              </ListItemIcon>
              <ListItemText primary={text} />
            </ListItem>
          ))}
        </List>

        <Divider />

Fijate que Navbar y Sidebar están a la misma altura.Usaremos la Context API para almacenar estados globales desde ahora.

						VIDEO 94 UI CONTEXT

En toda aplicación que tenga cierto nivel de complejidad tengo que comunicar información entre componentes y que puedan reaccionar cuando una variable o propiedad cambia.
Fijate que dejo un Snippet creado para crear un Context en TS.Entré con CTRL+SHIFT+p y 'userSnippets'.Despues seleccioné los globales:
	 "Create a Context in ReactTS": {
	 	"scope": "javascriptreact,typescriptreact",
	 	"prefix": "reactcontext-create",
	 	"body": [
      "import { createContext } from 'react';",
      "",
      "interface ${1:XXX}Props {",
      "  ${2:exampleProp}: ${3:boolean};",
      "}",
      "",
      "export const ${1:XXX}Context = createContext({} as ${1:XXX}Props);",
	 	],
	 	"description": "Creates a context in TS-React"
	 }
}
El scope muy importante.

				VIDEO 95 CREANDO EL CONTEXT PROVIDER

Turno de crear el Provider que consuma el Context y proveerlo a la app.También crearé un snippet para futuros casos.Fijate que es mejor idea de lo que parece.

				VIDEO 96 CREANDO EL REDUCER Y SU SNIPPET

El reducer es una función pura que recibe el state actual y una accion y produce el siguiente estado.
import { UIState } from "./UIProvider";

type UIAction = 
| { type: 'UI - Open Sidebar'}
| { type: 'UI - Close Sidebar'}

export const uiReducer = (state: UIState,action: UIAction):UIState => {
  switch (action.type) {
    case 'UI - Open Sidebar':
      return {
        ...state,
        sidemenuOpen:true
      }
    case 'UI - Close Sidebar':
      return {
        ...state,
        sidemenuOpen:false
      }
    default:
      return state;
  }
}
Adicionalmente,creo el snipet para un reducer.

				VIDEO 99 USANDO EL CONTEXT UI

Fijate que también es buena idea crear funciones en el componente Provider:

export const UIProvider: FC<UIProviderProps> = ({ children }) => {
  const [state, dispatch] = useReducer( uiReducer, UI_INITIAL_STATE);

  const openSideMenu = () => {
    dispatch({ type: 'UI - Open Sidebar' });
  }

  const closeSideMenu = () => {
    dispatch({ type: 'UI - Close Sidebar' });
  }

  return (
    <UIContext.Provider
      value={{
        // sidemenuOpen: state.sidemenuOpen,
        ...state, //mejor usar el spread operator
        openSideMenu,
        closeSideMenu,
      }}
    >
Diría que incluso necesario.Si está la posibilidad usala.
NOTA:fijate que esto implica cambiar el primer state inicial al crear el context


interface UIProps {
  sidemenuOpen: boolean;
  /* methods */
  openSideMenu: () => void;
  closeSideMenu: () => void;
}
Con todo esto puedo poner en el drawer que empiece en false y en el onClose se cierre:

const Sidebar = () => {
  const { sidemenuOpen,closeSideMenu } = useContext(UIContext);
  return (
    <Drawer anchor="left" open={sidemenuOpen} onClose={closeSideMenu}>

Y en la Navbar le paso el open al onClick sobre el icono:
const Navbar = () => {
  const { openSideMenu } = useContext(UIContext);

  return (
    <AppBar position="sticky">
      <Toolbar>
        <IconButton size="large" edge="start" onClick={openSideMenu}>

			SECCION 08 OPENJIRA APP -MANEJO DE ENTRADAS

En esta sección vamos a hacer de manera local todo el manejo de entradas al dashbard.Trabajaremos con más elementos de Material UI y también crearemos nuestra propia implementación de un Drag and Drop (sin librerías de terceros)

El objetivo principal es tener el control de las entradas y poder jugar con ellas a nuestra voluntad.

				VIDEO 105 DISEÑO DE LA PANTALLA PRINCIPAL

Recuerda que Next tiene una estructura para las pages muy concreta,asi que tendré en pages/index.ts lo que se vea en /,es decir en la pantalla principal.
Fijate que no es mismo el breakpoint xs que la propiedad sx para agregar CSS en MUI.En cuanto a la UI tres columnas desde sm y 1 en xs.Todo bastante sencillo:

const Home: NextPage = () => {
  return (
    <Layout title="Home - OpenJira">
      <Grid container spacing={2}>
        <Grid item xs={12} sm={4}>
          <Card sx={{ height: "calc(100vh - 100px)", }} >
            {/* cardheader es self-closed */}
            <CardHeader title="Pendientes" />
            <CardContent>
              {/* agregar una nueva entrada */}
              {/* listado de las entradas */}
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={4}>
          <Card sx={{ height: "calc(100vh - 100px)", }} >
            <CardHeader title="En Progreso" />
          </Card>
        </Grid>

        <Grid item xs={12} sm={4}>
          <Card sx={{ height: "calc(100vh - 100px)", }} >
            <CardHeader title="Completadas" />
          </Card>
        </Grid>
      </Grid>
    </Layout>
  );

NOTA: desde la v5 ya no es npm install @material/core sino @mui/material.Es decir que estoy trabajando con material UI pero la version 5.
La web es https://mui.com/

			VIDEO 106 ENTRIES CONTEXT - CONTEXTO PARA LAS ENTRADAS

Recuerda que estamos simulando Jira,una entrada será una tarea más bien.Bien,lo primero es instalar uuid para generar identificadores únicos(parece que lo haremos más adelante).
En cuanto al Contexto creamos todo lo relacionado para un EntriesContext.De momento poco más,hay que ver como luce una entrada antes de nada
Fijate que rápido fue con los snippets,y encima los mejoramos.

			VIDEO 107 INTERFACE ENTRY

Creamos la interface para el tipado:
export interface Entry {
  _id: string;
  description: string;
  createdAt: number;
  status: EntryStatus; 
}

export type EntryStatus = 'pending' | 'in-progress' | 'finished';

Y también creo tres entradas hardcodeadas para empezar como estado inicial:

const Entries_INITIAL_STATE: EntriesState = {
  entries: [
    {
      _id: uuidv4(),
      description:
        'lNisi sint do eiusmod enim commodo eu laborum ea reprehenderit do.',
      status: 'pending',
      createdAt: Date.now(),
    }, ...

		VIDEO 108 ENTRYLIST Y ENTRYCARD - COMPONENTES PARA MOSTRAR ENTRADAS

Comencemos creando un componente para listar las entradas segun tipo:
const EntryList = () => {
  return (
    /* usaré un div en vez de un Box para ver al onDrag */
    <div>
      <Paper
        sx={{
          height: 'calc(100vh - 200px)',
          overflow: 'auto',
          backgroundColor: 'transparent',
          padding: '1px 6px',
        }}
      >
        {/* TODO: cambiar estilo si esta en onDrag */}
        <List sx={{ opacity: 1 }}>
          <EntryCard />
        </List>
      </Paper>
    </div>
  );
};
export default EntryList;

Y el EntryCard también es bastante sencillo aún:
const EntryCard = () => {
  return (
    <Card sx={{ marginBottom: 1 }}>
      <CardActionArea>
        <CardContent>
          <Typography sx={{ whiteSpace: 'pre-line' }}>
            Esto es la descripcion del
          </Typography>
        </CardContent>
        <CardActions sx={{display:'flex',justifyContent: 'flex-end',paddingRight:2}}>
          <Typography variant='body2'>hace 30 minutos</Typography>
        </CardActions>
      </CardActionArea>
    </Card>
  );
};
export default EntryCard;

			VIDEO 109 MOSTRAR TARJETAS BASADO EN EL ESTADO DE LA ENTRADA


	


