				CURSO NEXT-JS EN TYPESCRIPT BY FERNANDO HERRERA

NOTA: la cascada en CSS va acompañada de la especificidad.A igual especificidad se aplicarán los estilos que estén más abajo,pero si se apuntará con diferente especificidad primero entraría ésta,antes que la cascada.

h2{
 font-size:10px
}
h2{
font-size:15px <- dado que la especificidad es la misma entra la cascada

body>h2{
font-size:15px <- dado que este selector es más especifico se aplica éste

h2{
 font-size:10px

Recuerda que puedo obligar a que se hereden propiedades como padding,border o width con el valor de inherit.Obviamente las propiedades que se heredan por defecto(como font-size o font-family las puedo cambiar sobrescribiendolas.
Para que un elemento se centre debe tener display block(no vale inline-block) y un width definido.
Sintaxis de un box-shadow:
.box {
  box-shadow: h-offset v-offset blur spread color
}
H-offset significa que tanto se va a desplazar la sombra en la horizontal
v-offset significa que tanto se va a desplazar la sombra en la vertical
blur es que tanto se va a difuminar
spread es que tanto se va a esparcir(fijate que es blur spread,por eso suelo ignorar la cuarta propiedad)
color: obviamente el color de la sombra
box-shadow: 2px 5px <- realmente solo necesito el h-offset y el vertical-offset,el blur y spread por defecto son 0 y el color es 'currentColor'.CurrentColor es como una variable,y por defecto es negro. 

* La sombra es una copia exacta del tamaño y de la forma del elemento con ella(si el elemento tiene un border-radius la sombra lo tendrá,etc).Esto es importante,pero lo puedo sobrescribir con el spread(spread expande la sombra,aunque esté haciendo la sombra a un div de 100x100 puedo usar un spread de 20px para aumentar la sombra a un div de 120x120.Y es por esto que no se suele tocar,normalmente no se agranda el tamaño de la sombra	
Recuerda que puedo concatenar sombras separandolas por una coma:
box-shadow: 100px 100px 0 0 crimsom, 100px 0 0 0 darkblue; <- dos sombras
IMPORTANTE: en las sombras no se suelen usar colores puros,normalmente se usan colores con opacidad como rgba(6,24,126,0.5) 

TIP:cuando trabaje con imagenes sin fondo puedo usar la propiedad filter con el método drop-shadow para darle sombra sólo a la imagen y no al contenedor de la imagen.Ésta es la sintaxis:
.goku {
   filter: drop-shadow(h-offset v-offset blur color) <- obviamente no tengo spread porque no puede calcular el resize de la imagen.Fijate que es un método.(aprender más sobre filter.
NOTA:puedo quitar el fondo a imagenes,para poder aplicar este filter,con cualquier herramienta online para ello(como remove.bg)
NOTA:fijate que puedo comprar el curso con Udemy Business de AlexCGDesign

					SECCION UNO

Esta es nuestra primera sección en la cual empezaremos a trabajar con Next.js, la cual es quizá la más importante de todas si estamos comenzando con este framework.

Puntualmente veremos:
1- Exposición sobre ¿Qué es Next.js?
2- Crear nuestro primer proyecto
3- Exposición sobre cada archivo y directorio
4- Componentes propios de Next (Link, Head)
5- Módulos de CSS y estilos globales
6- Páginas
7- API generada por defecto
8- Aplicar estilos basados en rutas
9- Layouts
10- Layouts anidados

Y más...

				EXPOSICIÓN INTRODUCTORIA A NEXT.JS

Next es un framework para servir contenido estático y generado desde el lado del servidor.
Es SEO friendly,optimiza imagenes,etc
Permite usar SSR y/o SSG(Static Site Generation).Un sitio static-site es un sitio que ofrece el mismo contenido una vez se hace el build.El SSR y el SSG realmente los puedo mezclar
También ofrece el CSR(Client Site Rendering) que es lo que hace React o Vite.
También ofrece el ISR(Incremental Static Regeneration).El ISR es muy parecido al SSG,se usa al agregar algo a un Sitio estático,para no tener que retocar todo.
Por último tiene DR(Dynamic Routing)

NOTA: un SPA es considerado como NO-SEO-friendly.Fijate que puedo ayudar a los bots de Google cuando quiera que no indexen mi web más(debería hacerlo).

			VIDEO 09 CREANDO MI PRIMER PROYECTO

La documentación del framework la tengo aqui(https://nextjs.org/).La dejo en assets,fijate que siempre debo tener la documentación a mano.

La forma más fácil de comenzar es con yarn create next-app (--typescript).Fijate en el espacio entre create y next-app,esto es porque usé yarn.
Si uso npx es npx create-next-app@latest --typescript(si quiero TS).Recuerda instalar yarn con npm i -g yarn

Fijate que Fernando tuvo problemas con el módulo autoprefixer y tuvo que configurar a postcss pasandole el plugin.En mi caso no sucedió

				VIDEO 10 PRIMEROS PASOS

NOTA: es obligatorio que las paginas sean functional components con la exportación por default.Esto lo puedo ver ya en pages/index.js:

export default function Home(){}

Otra cosa que puedo notar es que no tiene nada que ver el nombre del componente(Home) con el nombre del archivo.Perfectamente se podría llamar Alberto el componente que lo que importa es el nombre y ubicación del archivo

IMPORTANTE: los nombres de los archivos van en minúsculas también(no puedo llamarlo Index.js tiene que ser index.js).Sin embargo,si que puedo llamarlo index.jsx para ayudarme con el Intellisense,etc..(importante).
Si bien en React si se capitaliza el nombre del archivo en Next es obligatorio que empiecen por minuscula.El nombre del archivo creará la ruta(siempre que sea un archivo que está en pages/*)

NOTA: si abro una aplicación de Next desde afuera de la carpeta me puede dar un error que no encuentra next/babel.Hay que agregar esto al eslintrc.json:
{
  "extends": ["next/babel","next/core-web-vitals"]
}
Esto sólo sucede cuando no abra el IDE desde el root del proyecto como en un monorepo multiproyecto.

				VIDEO 11 ESTRUCTURA DE UN PROYECTO NEXT

La primera carpeta importante es la oculta '.next'.Este directorio es imprescindilbe y si no lo tuviera porque cloné un repo,por ejemplo,un simple yarn dev la reconstruirá(o un yarn build también,aunque creará otro contexto).

La segunda carpeta por orden sería node_modules.Fijate que muchos módulos pueden ser para desarrollo asi que diferirá de la que termine en el servidor.

La tercera carpeta es pages.Aqui cualquier archivo creará una url,siguiendo la sintaxis de Next(minusculas,export default,)

La cuarta carpeta es public.Aqui puedo meter estáticos como imagenes,fuentes,iconos,...Fijate que está carpeta no será compilada,simplemente será servido su contenido desde la carpeta.

La siguiente carpeta es 'styles'.Son los archivos de estilos de mi aplicación.Rápidamente podré ver que está el globals.css y el Home.module.css,identificando que tengo dos formas de trabajar con css,la normal(.css) y cssModules(Home.module.css).
Cabe destacar que los modules tienen que terminar en .module.css y que se usa Home para especificar que pertenece a ese componente,pero tanto este nombre como el de globals podrían ser otros

El resto son archivos de configuración, eslintrc.json para el linter,.gitignore, next.config.js para Next,el package.json para el proyecto npm,etc...

Puedo usar [1,2,3].at(-1) para acceder a la última posición.

			VIDEO 12 COMPONENTE NEXT/HEAD

El <Head> es un componente especial de Next que puedo usar en cada página y cambiará el html del <head> en esa página.Esto mejora el SEO,ya que los bots penalizan las SPA.
NOTA: el componente <Head> de Next no reemplaza al <head> de html.Simplemente agrega a la tag <head> lo que ponga en código en ese componente <Head>.

Puedo tener múltiples <Head>,incluso en el mismo componente:
      <Head>
        <title>About - Next Rocks</title>
        <meta name="description" content="Home Page" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Head>
        <title>About2 - Next Rocks</title>
        <meta name="description" content="About Page" />
      </Head>
Lógicamente por cascada sobreescribiré la <meta name="description> y el <title>

NOTA: Next desde la version 12 cambió el compilador.Ya no usa Babel,usa Rust lo cual da velocidades de hasta 5x más rápido.Esta versión salió en October,2021 y también trae compatibilidad para React18 y sus server components o el módulo Middleware,aparte del Rust Compiler

		VIDEO 13 STATIC GENERATION VS SERVER-SIDE RENDERING

Debo tener bien claro estos dos términos.Next tiene dos formas de pre-rendering.La diferencia entre ellas está en CUANDO SE GENERA EL HTML DE LA PAGINA:

Static Generation(Recommended): El HTML es generado en built time y será reusado en cada request
Server-side Rendering: el HTML es generado en cada request.

Next me permite elegir que pre-rendering elegir.Puedo incluso elegir Static Genertation para ciertas páginas y elegir Server-side Rendering para otras en las que pueda ser más adecuado

NOTA: Fijate que Next por defecto va a usar Static Generation.

NOTA:cuando tengo una pagina del tipo:saco el id de la ruta,busco en la BD y devuelvo ese registro hay es cuando debo usar ServerSideRendering(rutas dinámicas con peticiones).NO tiene sentido usar el caché ya que cada producto cambiará(tipica pagina de vista de UN Producto).
Otra página que su contenido no cambie debo usar la cache usando Static Generation.
IMPORTANTE: Next sabe que estrategia usar en base a funciones que usaremos muy pronto(getServerSideProps??).Ya lo veré.

Es importante comprender que Next funciona sin Javascript(puedo quitarlo momentáneamente).Esto mejora el SEO,ya que los bots de Google bonifican esto,no tener que leer javascript para poder ver algo.Amazon es un claro ejemplo de esto,y por el contrario una App de React caerá completamente al desactivar Javascript,penalizandola por ello

			VIDEO 14 COMPONENTE NEXT/LINK

Este video es muy importante.Cada vez que navego puedo notar que sucede un full refresh.Esto es porque estoy usando una etiqueta <anchor>.Nunca debo usar esta etiqueta.

 {/* Ir a <a href="/about">About</a> */}
 Ir a <Link href="/about">About</Link> 

NOTA: Next precargará cualquier <Link< que esté en el viewport(aunque tuviera que hacer scroll) en un segundo plano,haciendo la navegación instantánea.Esto lo puedo desactivar con la propiedad prefetch:boolean de ese componente Link

 Ir a <Link href="/about" prefetch="false">About</Link> 
Por defecto estará habilitado al estar en true.
Otra opción que debo manejar es la propiedad replace:boolean.Por defecto está en false,con lo que crea entradas en el historial de urls.Es muy útil cuando se navega al 404 no querer guardar esa entrada en el historial para ello hay que usar esta propiedad:
<Link href="/home" replace>Volver al Home</Link> <- desde la pag de error.
También se usa para que no pueda regresar al Login tras una autenticación exitosa.
NOTA:los componentes de React deben estar lo más limpios posibles de lógica.No es buena idea hacer un fetch en el useEffect.Es mejor crear un service con la lógica.De esta manera,no sólo dejo libre el componente,que no necesita saber si uso fetch o axios,solo necesita saber que esa funcion le devolverá la data.
Además,abstraerla en ese servicio me permite reutilizarla en cualquier otro componente o cambiarle la lógica en un futuro(cambiar a axios,etc).Desde luego son importantes,si.Mañana practicar con ello.

			VIDEO 15 COMPONENTES PERSONALIZADOS

IMPORTANTE: fijate que si quisiera crear un componente no lo puedo crear en pages/* ya que estaría creando una página.Debo crear el folder components 
Bien,si nos fijamos el pages/index.jsx y pages/about.jsx tienen casi el mismo código.Esto es mala práctica,pues estoy repitiendo código.Lo ideal es que cada componente tenga lógica diferente y no lo que tengo ahora.
Para resolver esto entra el concepto de Next llamado Layouts que veremos en breve

			VIDEO 16 BARRA DE NAVEGACIÓN PERSONALIZADA	

IMPORTANTE: esta navbar está mal,no debería usar <anchor> tags en Next.Debería usar su Link para que haga el pre-fetch de los componentes a los que redireccione:
    <nav>
      <a href="/">Home</a>
      <a href="/about">About</a>
      <a href="/contact">Contact</a>
    </nav>

Debo dejarlo asi:
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
      <Link href="/contact">Contact</Link>
    </nav>

NOTA: entre las caracteristicas que tienen los Links es que no puedo estilizarlosEs un componente que me entrega Next sin esta feature.Sin embargo,si quisiera podría pasarle una <anchor> tag como hija y estilizar a esta etiqueta.

<Link href="/about">
  <a style={{ marginRight: '10px' }}>About</a>
</Link>
* Además,debo recordar que Link necesita de la prop href,asi que puedo dejar de usarla en la tag anchor

Bien,volviendo al tema,podría parecer que pudiera enlazar a este archivo un simple navbar.css con por ejemplo esta regla:
a {
 margin-right: 10px;
}
Sin embargo veré el error que dice que solo el _app.js puede importar archivos css globales.
IMPORTANTE:Next me obliga a trabajar con archivos .module.css a excepción del file _app.js que si puede importar un .css a secas.

Bien,si ahora usará esa nomenclatura veré que aún me da otro error(selector "a" is not pure).
IMPORTANTE: un selector puro debe apuntar a una clase o un id(no puedo apuntar a una tag)
Si además le doy este nombre a la clase Css:
.menu-container a {
  margin-right:10px;
}
fijate que esto no es un nombre válido en Javascript:
<nav className={styles['menu-container']}> <- no puedo usar styles.menu-container pues estoy en Javascript(pero si que puedo usar una propiedad computada)
Es realmente una propiedad computada??

				VIDEO 17 CUSTOM ACTIVE LINK

Si voy a la documentación veré que no tengo ninguna propiedad estilo activeClassName con lo que habrá que hacerlo manualmente.Como es algo que vamos a repetir ya que tengo tres Links crearemos un componente llamado ActiveLink.

NOTA:fijate como se suele usar Link+a para tener lo mejor de los dos.El pre-fetch del LInk y la posibilidad de estilizar el ancla:

const style = {
  color: '#0070f3',
  textDecoration: 'underline'
}

export const ActiveLink = ({ text, href }) => {
  return (
    <Link href={href}>
      <a style={style}>{text}</a>
    </Link>
  )
Fijate que la solución es realmente simple,ya que siempre puedo saber la ruta actual,en este caso con el hook useRouter:
  const router = useRouter();
  const path = router.pathname;  

  return (
    <Link href={href}>
      <a style={ path === href ? style : null}>{text}</a>
    </Link>
  )
Esto podría aplicarlo a cualquier framework,realmente no necesito una clase activeClassName para nada
Por último fijate que Fernando tiene razón cuando dice que en vez de crear archivos pages/about.js o pages/contact.js puedo crear una carpeta pages/about o pages/contact y meter un index.js alli.
Esto es muy útil,ya que puede ser que tenga diferentes páginas como /contact y /contact/user o contact/home.Creando una carpeta podré meter estos tres files en ella.Hacer caso a Fernando

					VIDEO 18 LAYOUTS

En Next un layout es un simple functional component que recibe un children.
Recuerda que un HOC no es más que HTML que recibe otro HTML como hijo,es decir un Componente JSX(o varios).

<MainLayout>
  <Component />
</MainLayout> <- MainLayout es un HOC,pues recibe a Componente

IMPORTANTE: puede parecer que esto
<MainLayout page="Home">
y esto
<MainLayout page={"Home"}>
es lo mismo,pero en el primero no va a entrar el framework,mientras que el segundo es Javascript y va a entrar Next a interpretarlo.Si bien estamos usando Static Generation y nos da igual,está página haria el pre-fetch si uso page={"Home"}

Por lo demás quedará asi:
   <MainLayout page={'contact'}>

      <h1 className={'title'}>
        Ir a <Link href='/'>Home</Link>
      </h1>

      <p className={'description'}>
        Get started by editing{' '}
        <code className={'code'}>pages/contact.js</code>
      </p>
    </MainLayout>

			VIDEO 20 MULTIPLES LAYOUTS ANIDADOS

Es muy común trabajar con más de un Layout.Asi que vamos a crear otro.Inclusive se pueden crear Layouts anidados(un Layout que internamente tiene otro Layout).

Fijate que simple va a ser este layout que pone el fondo a un 30% opacidad:
const DarkLayout = ({ children }) => {
  return (
    <div
      style={{
        backgroundColor: 'rgba(0,0,0,0.3)',
        padding: 10,
        borderRadius: 5,
      }}>
      <div>
        {children}
      </div>
    </div>
  )
}
export { DarkLayout }

Ahora ya puedo englobar cualquier componente con este otro Layout:
export default function About() {
  return (
    <MainLayout page={'about'}>
      <DarkLayout>

        <h1 className={'title'}>
          Ir a <Link href='/'>Home</Link>
        </h1>

        <p className={'description'}>
          Get started by editing{' '}
          <code className={'code'}>pages/about.js</code>
        </p>
      </DarkLayout>
    </MainLayout>
  );
}
Fijate como estamos usando dos Layouts,podria usar los que quisiera,es un simple HOC más.Sin embargo,hay otra forma de realizar esto,usando el prototype del componente para agregarle una función nueva como propiedad:

About.getLayout = function getLayout(page) {
   return (
    <MainLayout>
      <DarkLayout>
        {page}
      </DarkLayout>
    </MainLayout>
  )
}

Ahora puedo ir al _app.js y revisar en el componente que se está queriendo renderizar o generar si tiene ese método,gracias a que esta función iterará por todos los componentes de la App,algo bastante útil,como puedo observar:

function MyApp({ Component, pageProps }) {
  /* buscar por la funcion getLayout en cada componente.Si no la tiene simplemente devuelves la página(no hagas nada) */
  const getLayout = Component.getLayout || ((page) => page);

  return getLayout(<Component {...pageProps} />,'about');

NOTA DE LA DOC: este proceso se llama reconciliation y mediante este getLayout puedo persistir el state(input values,scroll position).Esto es asi porque Reacst mantiene el arbol de componentes entre el cambio de páginas:

Con Typescript cambia un poco:

import type { ReactElement } from 'react';

Page.getLayout = function getLayout(page: ReactElement) {
  return (
    <Layout>
      <NestedLayout>{page}</NestedLayout>
    </Layout>
  )
}

Y en el _app.js hay que usar algunas intersecciones,para añadir a las interfaces NextPage y AppProps esté metodo getLayout que añadimos al prototype:

import type { ReactElement, ReactNode } from 'react'
import type { NextPage } from 'next'
import type { AppProps } from 'next/app'

type NextPageWithLayout = NextPage & {
  getLayout?: (page: ReactElement) => ReactNode
}

type AppPropsWithLayout = AppProps & {
  Component: NextPageWithLayout
}

export default function MyApp({ Component, pageProps }: AppPropsWithLayout) {
  // Use the layout defined at the page level, if available
  const getLayout = Component.getLayout ?? ((page) => page)

  return getLayout(<Component {...pageProps} />)
}
Puedo ver que queda muy claro todo y es una gran aproximación.

				VIDEO 21-22 RESUMEN DE LA SECCIÓN

recuerda que una página en Next puede haber sido previamente generada,mediante Static Generation(todo lo que hemos hecho hasta ahora es Static Generation).Ya veremos como pasar de aqui.
Si hago el yarn build puedo ver estos simbolos:

λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses no initial props)

Lo que tenga el simbolo de lambda son páginas,endpoints,etc que va a ser ejecutado de lado del servidor cuando se haga una solicitud(esto es SSR,ya que se esta srirviendo antes en el Servidor)
Los que tengan el simbolo O significa que fue generado de manera estática.Al ser generado de manera estática TAMBIÉN FUE GENERADO ANTES DE QUE LA PERSONA HAGA LA SOLICITUD,ya están creadas y van a ser servidas de manera estática.

IMPORTANTE: si tras hacer ese build voy a la carpeta .next/server/pages veré a contact.html | index.html | about.html ,observando que realmente ya están los archivos ahi,y no tienen que generarse

○ /404                                   194 B          71.1 kB
├ ○ /about                                 502 B            74 kB
├ λ /api/hello                             0 B              71 kB
├ ○ /contact                               401 B          73.9 kB
└ ○ /pricing                               532 B          74.1 kB
Todas las que tienen un circulo tendrán su estático(.html) tras hacerse el build en .next/server/pages.
Desde luego es un framework sumamente interesante.En la siguiente sección migraremos esta app a Typescript y la desplegaremos con Docker.

		SECCION 03 NEXT CON TYPESCRIPT + DESPLIEGUE CON DOCKER

En esta sección veremos como desplegar nuestra aplicación de Next en distintos lugares.

Puntualmente veremos:

1- Convertir una aplicación de Next.js en JavaScript a TypeScript
2- Generar el build de producción / distribución
3- Desplegar la aplicación en Vercel (Creado por la misma gente de Next.js)
4- Generar una imagen de Docker
5- Crear la imagen de Docker siguiendo las prácticas recomendadas por Next
6- Correr la aplicación desde Docker Desktop

			VIDEO 27 MIGRANDO DE JAVASCRIPT A TYPESCRIPT

NOTA: tipado dinámico es que una variable puede cambiar de string a number(recuerda dinámico,que puede cambiar).Javascript es dinámico,Java es estático.
Por otro lado,tipado débil es que sin decirle el tipo lo infiere(let palabra = 'casa' < si hago un typeof ya ha inferido que es string)
Typescript es de tipado estático y no me va a permitir que esa variable palabra sea un number,permanecerá como string en runtime
Typescript es un supraconjunto de Javascript 
Recuerda que Typescript ve los errores en buildtime,en tiempo de compilación,y los muestra en el IDE(muestra los errores que irian a suceder al compilar)
Esto es bueno,ya que no llegarán los errores al tiempo de ejecución del script,pues no compilará

Bien,volviendo al video,para migrar a TS hay que crear un tsconfig.json en la raiz del proyecto(fijate en la libreria npm touch-cli que se puede instalar en windows para usar el comando touch).
Me faltará instalar typescript y los types para react y node(en desarrollo todo):
yarn add -D typescript @types/react @types/node

En cuanto levante la app llenará ese tsconfig.json con la configuracíon recomendada.También debería crear el next-env.d.ts.Desde luego,no puede ser más sencillo.
Doc:https://nextjs.org/learn/excel/typescript/create-tsconfig 	 

NOTAS: fijate que puedo tipar un objeto como CSSProperties.De esta forma sólo podré escribir reglas CSS en él.Algo que necesitaré en Typescript a menudo:
i
mport { CSSProperties, FC } from 'react';

const style: CSSProperties = {
  color: '#0070f3',
  textDecoration: 'underline'
}

type Props = {
  text: string;
  href: string;
}

export const ActiveLink: FC<Props> = ({ text, href }) => {

  const router = useRouter();
  const path = router.pathname;  

  return (
    <Link href={href}>
      <a style={ path === href ? style : undefined}>{text}</a>
    </Link>
  )
}
Recuerda que hay diferencias entre React.Element | JSX.Element y React.ReactNode.Y React.Fc<T> es la mejor solución.

Un ReactNode es un ReactElement | ReactFragment | string | number | null | undefined | boolean | ReactNode[]  <- o sea que puede ser cualquier cosa:

type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;

Ese ReacElement es muy parecido a JSX.Element(un JSX.Element es un ReactElement cuyas props and type son de tipo any).
ReactNode es lo que devuelve el método render() en una class extends React.Element.
En resumen puedo asignar casi cualquier cosa a ReactNode,con lo que es preferible usar tipos más fuertes

			VIDEO 29 MIGRANDO EL _app.jsx a _app.tsx

Antes de nada,fijate que en el endpoint debo tipar los argumentos,y que si sé como luce la response debería tiparla también:

type Data = {
  name: string
}

export default function handler(req: NextApiRequest, res: NextApiResponse<Data>) {
  res.status(200).json({ name: 'John Doe' })
}
En cuanto al uso de type o interface ,sabiendo que la response no va a cambiar ni voy a heredar o usar este contrato en otro lado puedo usar type perfectamente.

Ahora si,vayamos al _app.tsx ya que es muy interesante,pues usaré dos intersecciones para expandir la funcionalid de las interfaces por default para que tengan el método getLayout que recordemos que mantenia el state entre páginas de esta forma:

type NextPageWithLayout = NextPage & {
  getLayout?: (page: ReactElement, name?: string) => ReactNode;
};

type AppPropsWithLayout = AppProps & {
  Component: NextPageWithLayout;
};

function MyApp({ Component, pageProps }: AppPropsWithLayout) {

  const getLayout = Component.getLayout || ((page) => page);
  return getLayout(<Component {...pageProps} />, "about");

}
IMPORTANTE: fijate que este archivo devuelve JSX asi que debe acabar en tsx.

Sólo faltaría ir por cada page que llame a algun layout e indicarlo:
Pricing.getLayout = function getLayout(page: JSX.Element) {

			VIDEO 30-31 DESPLEGANDO NUESTRA APP

Las formas más comunes de despliegue son usando Docker,usando un servicio como Vercel,Firebase,etc o usando la intranet con el comando yarn build + yarn start(que llamará a next start)  y dejar el script corriendo y dando visión al equipo,etc.
Obviamente la tercera es la forma menos recomendada.
NOTA: usar yarn start levanta un servidor muy parecido al de express ya configurado con los paths,etc.Muy útil,aunque sea la opción menos recomendada.

Desplegarlo con vercel es muy sencillo,ya que crearon Next.Enlazamos el repositorio remoto y lo desplegamos

			VIDEO 32-33 GENERANDO IMAGEN DOCKER Y DESPLEGANDOLA

Fernando provee un gist con dos formas de crear el Dockerfile,la más simple genera una imagen demasiado pesada,asi que es mejor usar la ligera.
NOTA:fijate que tengo que activar experimental en el next.config.js para que no dé fallo el Dockerfile que me da Next:

* en el next.config.js

const nextConfig = {
  reactStrictMode: true,
  experimental:{
    outputStandalone: true
  }
}
Esta configuración hace que la imagen sea más pequeña.También recomiendan cambiar el script start:
  "start": "next start -p ${PORT:=3000}", < fijate que es Go.

Puedo ver que con esa opción me va bien el node server.js y que el despliegue es correcto

			SECCION 04 STATIC GENERATED APP - POKEMON APP

Llegamos a un punto muy interesante,que es la generación estática.Imaginando que sólo hay 151 pokemones y que nunca cambian,ya sabemos que el pokemon 1 es bulbasaur,que el 2 es pikachu,que hay 151,etc asi que va a lucir igual siempre nuestra app,y podemos decirle a next que cachee todo.
Es como si creará esos pokemon1.html,pokemon2.html y almacene esos 151 archivos html que nunca cambiarán.Esto lo consigo mediante getStaticPath y getStaticProps(supongo que el primero hace la rutas).
NOTA: al usar estos métodos Next sabrá al hacer el build que debe comportarse de esta forma.

Esta sección es sumamente importante para comprender cómo podemos crear de forma estática páginas aunque tengan argumentos dinámicos.

Puntualmente veremos:
1- Multiples componentes de NextUI
2- Flex Layout
3- Temas de NextUI
4- Next _document
5- Navegación
6- Parámetros por URL
7- Parámetros estáticos
8- Next - GetStaticProps
9- Next - getStaticPaths
10- Generar 151 páginas de forma estática en tiempo de construcción (build time)

Fijate que usaré NextUI como libreria de estilos y que realmente no voy a crear 151 páginas en desarrollo,pero si en el buildtime.

			VIDEO 38 INICIO DE SECCIÓN - POKEMON STATIC

Vamos a crear un proyecto de absoluto cero.Una de las mejores formas que tengo de crearlo es con :
yarn create next-app --typescript <- ¿no pide @latest?

						VIDEO 40 NEXTUI LIBRARY

NextUI casualmente no tiene ninguna relación con Next,es una libreria de componentes de React únicamente(posiblemente en un futuro lo añadan para Angular o Vue)
>npm install @nextui-org/react

NOTA: puedo observar que la libreria está en Beta.No se recomienda para un proyecto serio en producción.
Puedo observar que son bastante bonitos los componentes que ofrece.
	
Para que NextUI funcione correctamente tengo que usar el HOC <NextUIProvider> en el punto más alto:

import { NextUIProvider } from '@nextui-org/react';

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <NextUIProvider>
      <Component {...pageProps} />
    </NextUIProvider>
  );

IMPORTANTE: NextUI recomienda hacer un flush completo de los estilos de la aplicación.Para ello hay que crear el file _document.js

				VIDEO 42 FILE _document.js

Para que los estilos de la libreria se vean igual en cualquier navegador hay que llamar a CssBaseLine en ese archivo _document.js.
NOTA: puedo usar un custom Document para aumentar funcionalidad en las etiquetas <html> y <body>.Para ello debo sobreescibir en ./pages/_document.js el Document por defecto de esta forma(u otra que necesite).
TIP: usualmente un file que empiece por _ es algo especial de Next

			VIDEO 43 IMPLEMENTANDO EL THEME DARK

Si bien podria pasar al HOC <NextUIProvider theme=""> el tema no lo vamos a hacer en duro,pues queremos cambiarlo en tiempo de ejecución.

Lo que haremos es crear el file themes/darktheme.ts:

import { createTheme } from '@nextui-org/react';

export const darkTheme = createTheme({
  type: 'dark',
  theme: {
    colors: { }
  }
}) 

					VIDEO 44 LAYOUT PRINCIPAL

Usualmente no se sabe cuantos layouts tendrá la app,asi que siempre debo considerar que tendrá varios y trabajar en base a esa idea.Es buena idea crear la carpeta layouts con los layouts y usar un barrel file para exportaciones masivas:
export const Layout: React.FC<LayoutProps> = ({
  children,
  title,
}: LayoutProps) => {
  return (
    <>
      <Head>
        <title>{title ?? "Pokemon App"}</title>
        <meta name="author" content="Oscar Gonzalez" />
        <meta
          name="description"
          content={`Información sobre el pokémon ${title}`}
        />
        <meta name="keywords" content={`${title}, pokemon, pokedex`} />
      </Head>

      <Navbar />

      <main
        style={{
          padding: "5px 20px",
        }}
      >
        {children}
      </main>
    </>

NOTA: parece que al final es igual usar una clase que un estilo inline en Next.Investigar más sobre esto.Asi que para pequeños estilos como ese padding puedo usar el atributo style.

					VIDEO 44 CREANDO LA NAVBAR

Dado que estamos usando la libreria en beta NextUI puedo poner la navbar del color que quiera accediendo al theme con el hook useTheme(). Fijate que puedo acceder a isDark o alguna otra propiedad:

export const Navbar = () => {

  const {theme} = useTheme();
  
  return (
    <div
      style={{
        display: "flex",
        width: "100%",
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "start",
        padding: "0px 20px",
        backgroundColor: theme?.colors.gray900.value,
      }}
    >
      <span>hola</span>
    </div>
  );
};

La Navbar va a ser algo muy sencillo:
      <Image
        src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/132.png"
        alt="icono de la app"
        width={70}
        height={70}
      />
      <Text color="white" h2>
        P
      </Text>
      <Text color="white" h3>
        okémon
      </Text>

      {/* si son componentes de NextUI se recomienda usar el atributo css en vez de style para dar estilos en linea */}
      <Spacer css={{ flex: 1 }} />
      <Text color="white" h3>
        Favoritos
      </Text>

NOTA: fijate que Next por defecto va a usar Static Generation,y le estoy dando una URL para que busque la imagen.Dado que podria ser una url a un script malicioso,etc, le tengo que indicar que es un dominio válido donde puede ir a buscar imágenes.

					VIDEO 45 NEXT - GET STATIC PROPS	

Esta clase es de las más importantes.Mentalicemonos de que sólo vamos a mostrar los 151 primeros pokémones.Da igual qué usuario,o cuando siempre voy a mostrar los 151 primeros pokemones.
Entonces,yo ya sé quienes son y qué es lo que voy a mostrar.Siempre serán los mismos 151 pokemones.Luego,antes de que la persona haga el request ya sé qué debo mostrar.

Si voy a la documentación de Next veré que puedo hacer SSR( Server-side rendering) o SSG( Static-site generation) u otras como CSR(Client-side rendering,lo que hace React) o ISR( Incremental Static Regeneration).
El mejor rendimiento lo da el SSG(obviamente,pues está cacheado todo).

NOTA: cuando hago SSG todas las páginas html se crean en el servidor y cuando el usuario hace una request el servidor simplemente manda la pag web ya construida,ya la tiene construida(se puede hidratar con javascript,ya lo veremos)

IMPORTANTE: obviamente no siempre voy a poder usar StaticSiteGeneration pues si el usuario necesita datos actualizados o dinámicos,etc tendré que usar ServerSideRendering

SUPERIMPORTANTE: si yo exporto una función con el nombre 'getStaticProps' desde una Page,automáticamente Next construirá esta página en el buildtime(al hacer el build).Se enviará al cliente desde esa cache.

Recuerda que estas funciones getXXX sólo puedo usarlas en páginas y que se ejecutan en el lado del servidor,pudiendo acceder al file-system del user, a bases de datos,acceder a tokens,...
IMPORTANTE: y no sólo esto,sino que nada de lo que ejecute en esa función llega al cliente,a no ser que lo mande explicitamente en las props del return.

				VIDEO 46 TRAER DE FORMA ESTÁTICA LOS POKEMONS

NOTA: los Barrelfiles son para el pattern Barrelimports.Bien,instalemos axios y creemos una instancia nuestra :

import axios from "axios";

const pokeApi = axios.create({
  baseURL:'https://pokeapi.co/api/v2',
  headers:{'Content-Type': 'application/json'}
})

export default pokeApi;

Puedo ver que la data se me devuelve asi,teniendo que realizar otra petición encadenada:
{ name: 'onix', url: 'https://pokeapi.co/api/v2/pokemon/95/' },
{ name: 'drowzee', url: 'https://pokeapi.co/api/v2/pokemon/96/' },
{ name: 'hypno', url: 'https://pokeapi.co/api/v2/pokemon/97/' },
{ name: 'krabby', url: 'https://pokeapi.co/api/v2/pokemon/98/' },
{ name: 'kingler', url: 'https://pokeapi.co/api/v2/pokemon/99/' },

Además,esto está en data.results.Asi que será buena idea sacar el tipo de la response.

				VIDEO 47 COLOCAR EL TIPO DE RESPUESTA EN AXIOS

IMPORTANTE: fijate que la extensión del IDE requiere tener en el portapapeles toda la response a tipar.

// Generated by https://quicktype.io
/* fijate que la puta extensión requiere tener JSON en el portapapeles */
export interface PokemonListResponse {
  count:    number;
  next?:     string;
  previous?: string;
  results:  SmallPokemon[];
}

export interface SmallPokemon {
  name: string;
  url:  string;
}

/* recuerda que estas funciones sólo se pueden ejecutar en pages y que se ejecutan en el lado del servidor */
export const getStaticProps: GetStaticProps = async (ctx) => {
  const { data } = await pokeApi.get<PokemonListResponse>("/pokemon?limit=151");
  return {
    props: {
      pokemons: data.results,
    },
  };
};

export default HomePage;

Desde luego este tipo de pasos son fundamentales.Podria probar a crear el adaptermañana.

			VIDEO 48 TAREA - MOSTRAR NOMBRE Y NUMERO-ID DEL POKEMON

Para la tarea necesitaré transformar la data para ver tanto el id como el svg.
  const pokemons: SmallPokemon[] = data.results.map( (pokemon,index) => {
     return {
      id: index + 1,
      name: pokemon.name,
      url: pokemon.url,
      img: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/dream-world/${index + 1}.svg`,
    }; 
  });
NOTA: si hago el build veré una nueva opción SSG marcada con un punto blanco:
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)
Indicará que esa page está usando SSG

IMPORTANTE: veré un index.json(o el nombre de la page.json) con la data para generar la página en el build.

				VIDEO 49 MOSTRAR TARJETAS DE POKEMONS

Es momento de crear unas tarjetas.LLegados a este punto,puedo observar que esta libreria pinta muy bien y tiene un acabado espectacular y muchas opciones:

return (
    <Layout title="Listado de pokemons">
      <Grid.Container gap={2} justify="flex-start">
        {pokemons.map((pokemon) => (
          <Grid xs={6} sm={3} md={2} key={pokemon.id} xl={1}>
            <Card cover hoverable clickable animated>
              <Card.Body css={{ p: 1 }}>
                <Card.Image 
                  src={pokemon.img}
                  alt={pokemon.name}
                  width="100%"
                  height={230}
                />
              </Card.Body>
              <Card.Footer
                blur
                css={{
                  position: "absolute",
                  bgBlur: "#0f1114",
                  borderTop: "$borderWeights$light solid $gray700",
                  bottom: 0,
                  zIndex: 1,
                }}
              >
                <Row justify="space-between">
                  <Text transform="capitalize" >{pokemon.name}</Text>
                  <Text>#{pokemon.id}</Text>
                </Row>
              </Card.Footer>
            </Card>
          </Grid>
        ))}
      </Grid.Container>
    </Layout>
  );

					VIDEO 50 COMPONENTE PARA LAS TARJETAS

Dado que es mejor crear un componente para cada tarjeta hagamoslo.Fijate que la mejor idea es usar React.FC<T>.Fijate que va genial.Acostumbrate,ya que laboralmente también es la mejor opción.

			VIDEO 51 RECIBIR ARGUMENTOS POR URL Y NAVEGACIÓN

Hay varias tecnicas para navegar,ya hemos visto el <Link> de Next,que hace un barrido por los que haya en pantalla y los cachea,pero no permitia estilizarlos,por ello se embebe una <anchor> y se estiliza a ella.

Pero esta vez vamos a hacerlo de otra manera.Fijate además que sabemos que sólo va a haber 151 pokemones,y más importante aún,ya sé de antemano qué información voy a mostrar(sé que el 1 es bulbasaur,no va a cambiar,que el 2 es pikachu,etc...)
NOTA: y si cambiará está la feature que nos ofrece Next ISR(Incremental Static Regeneration),que ya veremos.

Bien,en cuanto a como crear una ruta dinámica en Next nada nuevo,creo un file en pokemon/[id].tsx con la export por default( recuerda que las pages van por default) y ahora puedo rescatar ese id tanto en el lado del servidor como del frontend:

Primero navego desde la Card
 <Card cover hoverable clickable animated
      onClick={() => router.push(`/pokemon/${pokemon.id}`)}>
NOTA: router.push({}) o router.push("") lleva varias firmas.Puede ser un objeto,aunque normalmente es un string.

Bien,si voy a la page dinámica pokemon/[id] veré ese id en router.query(fijate que el router en Next vale para todo)

IMPORTANTE: Udemy realiza ISR(cada 24h recachea todo).Mediante ISR puedo indicar a Next un tiempo y Next recacheará lo indicado de nuevo

Pero antes de comprender el ISR tengo que dominar el SSG,pero esta vez,con argumentos.

				VIDEO 52 NEXT GET STATIC PATHS

Cuando yo exporte la función getStaticPaths(SSG) desde una página que use ruteo dinámico(como es el caso de pages/pokemon/[id]) Next.js pre-renderizará estáticamente todos los paths indicados en getStaticPaths(fijate que es la homóloga de getStaticProps)

NOTA: recuerda que tanto getStaticProps como getStaticPaths guardarán HTML + JSON
Y recuerda que las páginas no cambian(aunque se pidan dinámicamente,el 1 siempre será el mismo pokemon,el 2 igual,etc)

IMPORTANTE: no sólo tengo que usar getStaticPaths por ser una página dinámica,sino que no podría usar getStaticProps por ello(veré el error por la UI).Debo usar getStaticPaths en cuanto sea una página dinámica([id].tsx).

IMPORTANTE: al usar SSG en una page dinámica y por ello su método getStaticPaths tengo que pasar los params como un string(ya que son un string) y además un tipo de fallback:

export const getStaticPaths: GetStaticPaths = async (ctx) => {
  return {
    paths: [ { params: { id: "1" }, }, ],
    fallback: "blocking", <- normalmente usaré false
  };
};

NOTA: getStaticPaths requiere de getStaticProps también,no tiene sentido por sí solo.Recuerda también que ambas funciones se ejecutan en el servidor.

		VIDEO 153 GENERANDO LAS 151 PÁGINAS ESTÁTICAS PARA CADA POKEMON

Obviamente primero tendré que generar un arreglo de strings con valores del "1" al "151".Cualquier forma valdŕa:
const pokemons151 = [...Array(151).keys()].map(x => String(x+1));

Ya sólo falta crear el bucle para el arreglo de paths:
 paths: pokemons151.map(id => ({ params: { id } })), <- fijate en que id:id se computará a id: "1", id: "2"

IMPORTANTE: una vez dicho a Next cuales son todos los paths que quiero cachear,tengo que usar getStaticProps,y realizar la petición:

/* getStaticProps recibirá los paths de getStaticPaths en ctx. */
export const getStaticProps: GetStaticProps = async (ctx) => {
  /* al loro con esto,asinto, castea desde la propiedad padre */
  const { id } = ctx.params as { id: string };

  const { data } = await pokeApi.get<PokemonResponse>(`/pokemon/${id}`);
  return {
    props: {
      pokemon: data,
    },
  };
};

Fijate que el id lo necesitamos para pedir el pokemon(realmente no creo que tenga nada que ver getStaticPaths,el ctx.params también accede al param.

IMPORTANTE: es muy importante entender que en modo dev no puedo apreciar bien lo que está sucediendo,pues cada refresh hace que Next ejecute todo otra vez,pero el objetivo es que se haga el build una vez y se cacheen los 151 posibles destinos una vez(puedo ver esto con un yarn build)
Inclusive al dejar el console.log puedo ver que ha pedido las 151 páginas al hacer el build(fijate lo poderoso que es Next):

┌ ● / (326 ms)                             5.39 kB        98.1 kB
├   /_app                                  0 B              86 kB
├ λ /404                                   192 B          86.2 kB
├ λ /api                                   0 B              86 kB
├ λ /api/pokeApi                           0 B              86 kB
└ ● /pokemon/[id] (35660 ms)               880 B          93.6 kB
    ├ /pokemon/2 (382 ms)
    ├ /pokemon/149 (343 ms)
    ├ /pokemon/150 (332 ms)
    ├ /pokemon/148 (331 ms)
    ├ /pokemon/61 (315 ms)
    ├ /pokemon/65 (313 ms)
    ├ /pokemon/145 (313 ms)
    └ [+144 more paths]

Obviamente tardó 35 segundos ya que ha cacheado 151 paginas el illoputa.Esto lo hará sólo una vez,ojo.Puedo hacer el yarn start y comprobar todo eso.
NOTA: no hay tiempos de carga,jaja.Increible

					VIDEO 54 DISEÑO DE LA PÁGINA DE POKEMON

Fijate que a la hora de utilizar SSG tengo que tener cuidado,en este caso la petición devuelve mucha data y el json que se generará ocupará espacio en el disco duro del cliente.
La recomendación de Next(y Fernando) es ser meticulosos con lo que se almacene.En este ejemplo dejaremos la respuesta así de extensa,pero no es lo que debo hacer en una aplicación real.
En cuanto al componente fijate de nuevo que esta libreria es bastante bonita,quizás también bastante informal.

				VIDEO 55 NAVEGACIÓN Y PÁGINA DE FAVORITOS

Fijate como he tenido que renombrar el Link de Next dado que se llama igual que el Link de NextUI(hay que usar el LInk de la libreria porque el Link de Next no permite tener múltiples hijos,asi que se le pasa un único hijo que es el Link de NextUI,el cual obviamente si permite tener dos Text como hijos:

import NextLink from "next/link";
import { Link, Spacer, Text, useTheme } from "@nextui-org/react";

      <NextLink href="/" passHref>
        <Link>
          <Text color="white" h2>
            P
          </Text>
          <Text color="white" h3>
            okémon
          </Text>
        </Link>
      </NextLink>

Hago lo mismo para el otro link,fijate que el Link de la libreria ya trae el cursor pointer.

				VIDEO 56 RESUMEN DE LA SECCIÓN

Fijate que basicamente tenemos una aplicación de React,a excepción de la parte de las staticProps.
Las staticProps generan al hacer el build archivos .html + .json los cuales cacheará y llamará en runtime(no hará peticiones a la API).
NOTA: fijate que realizó 151 peticiones a la API al realizar el build,realmente no me importa,pues la data no va a cambiar.
Recuerda también que las funciones getStaticProps,getStaticPaths,etc se ejecutan SOLO en el servidor.

IMPORTANTE: a pesar de tener 151 páginas generadas estáticamente yo aún puedo operar sobre ellas(pulsar en botones,guardarlas en favoritos,...)Fijate en este detalle,aún puedo tener funcionalidad sobre ellas,aunque estan cacheadas.
A esto se le llama 'hidratar la página con código de React' <- en realidad también puede ser con Javascript(simplemente 'hidratar la página').
Hidrataremos la página posteriormente(por ejemplo,podría traer la sección de comentarios bajo demanda,cada vez que se visite la página,pero tener las cards estáticas).Fijate que Udemy hace esto con los precios y las desc de los cursos.

NOTA: fijate que todo esto me debe llevar a pensar desde un principio qué es lo que quiero cachear y qué no.
